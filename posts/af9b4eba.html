<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Redis-知识汇总 | D丶Cheng的博客</title><meta name="description" content="Redis简介简单介绍Redis：开源、免费、非关系型数据库、K-V数据库、内存数据库，支持持久化、事务和备份，集群(支持16个库)等高可用功能。并且性能极高(可以达到100000+的QPS)，易扩展，丰富的数据类型，所有操作都是单线程,原子性的。 NOSQL：非关系型数据库，数据与数据之间没有关联关系。就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题 类型  键值(key-"><meta name="keywords" content="Redis"><meta name="author" content="D丶Cheng"><meta name="copyright" content="D丶Cheng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://chave-z.github.io/posts/af9b4eba.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Redis-知识汇总"><meta property="og:url" content="https://chave-z.github.io/posts/af9b4eba.html"><meta property="og:site_name" content="D丶Cheng的博客"><meta property="og:description" content="Redis简介简单介绍Redis：开源、免费、非关系型数据库、K-V数据库、内存数据库，支持持久化、事务和备份，集群(支持16个库)等高可用功能。并且性能极高(可以达到100000+的QPS)，易扩展，丰富的数据类型，所有操作都是单线程,原子性的。 NOSQL：非关系型数据库，数据与数据之间没有关联关系。就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题 类型  键值(key-"><meta property="og:image" content="https://chave-z.github.io/null"><meta property="article:published_time" content="2020-06-01T04:02:00.000Z"><meta property="article:modified_time" content="2021-12-15T06:19:45.357Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '天',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: {"limitCount":50,"languages":{"author":"作者: D丶Cheng","link":"链接: ","source":"来源: D丶Cheng的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2021-12-15 14:19:45'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.1.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/null" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Chave-Z/picture@master/data/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">88</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">16</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">16</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 所有文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">Redis简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">简单介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-number">1.2.</span> <span class="toc-text">redis的安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8NOSQL"><span class="toc-number">1.3.</span> <span class="toc-text">为什么使用NOSQL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E6%9C%BA-MySQL-%E7%9A%84%E7%BE%8E%E5%A5%BD%E6%97%B6%E4%BB%A3"><span class="toc-number">1.3.1.</span> <span class="toc-text">单机 MySQL 的美好时代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Memcached-%E7%BC%93%E5%AD%98-MySQL-%E5%9E%82%E7%9B%B4%E6%8B%86%E5%88%86"><span class="toc-number">1.3.2.</span> <span class="toc-text">Memcached(缓存)+MySQL+垂直拆分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mysql%E4%B8%BB%E4%BB%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-number">1.3.3.</span> <span class="toc-text">Mysql主从读写分离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-%E6%B0%B4%E5%B9%B3%E6%8B%86%E5%88%86-mysql%E9%9B%86%E7%BE%A4"><span class="toc-number">1.3.4.</span> <span class="toc-text">分库分表+水平拆分+mysql集群</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8DNoSQL%E5%AF%B9%E6%AF%94"><span class="toc-number">1.4.</span> <span class="toc-text">四种NoSQL对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3V-3%E9%AB%98"><span class="toc-number">1.5.</span> <span class="toc-text">3V+3高</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ACID"><span class="toc-number">1.6.</span> <span class="toc-text">ACID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAP"><span class="toc-number">1.7.</span> <span class="toc-text">CAP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BD%95CAP%E4%B8%89%E8%80%85%E4%B8%8D%E5%8F%AF%E5%85%BC%E5%BE%97"><span class="toc-number">1.8.</span> <span class="toc-text">为何CAP三者不可兼得</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Base"><span class="toc-number">1.9.</span> <span class="toc-text">Base</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%92%8C%E9%9B%86%E7%BE%A4"><span class="toc-number">1.10.</span> <span class="toc-text">分布式和集群</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">2.</span> <span class="toc-text">解析配置文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">3.</span> <span class="toc-text">Redis的持久化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E4%BA%8B%E5%8A%A1"><span class="toc-number">4.</span> <span class="toc-text">Redis的事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E5%B9%B2%E5%98%9B%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">能干嘛？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">4.3.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%99%E4%B9%88%E7%8E%A9%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">这么玩？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">4.5.</span> <span class="toc-text">乐观锁和悲观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Watch%E7%9B%91%E6%8E%A7"><span class="toc-number">4.6.</span> <span class="toc-text">Watch监控</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E9%98%B6%E6%AE%B5"><span class="toc-number">4.7.</span> <span class="toc-text">3阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E7%89%B9%E6%80%A7"><span class="toc-number">4.8.</span> <span class="toc-text">3特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85-%E4%B8%80%E8%88%AC%E4%B8%8D%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">Redis的发布订阅(一般不用)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">5.0.1.</span> <span class="toc-text">发布订阅</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E5%A4%8D%E5%88%B6%EF%BC%88Master-Slave%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">Redis的复制（Master&#x2F;Slave）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-1"><span class="toc-number">6.1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E5%B9%B2%E5%98%9B%EF%BC%9F-1"><span class="toc-number">6.2.</span> <span class="toc-text">能干嘛？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%8E%A9%EF%BC%9F"><span class="toc-number">6.3.</span> <span class="toc-text">怎么玩？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%BB%E4%BB%8E%E6%96%B9%E5%BC%8F"><span class="toc-number">6.4.</span> <span class="toc-text">常用的主从方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%86"><span class="toc-number">6.4.1.</span> <span class="toc-text">一主二仆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%96%AA%E7%81%AB%E7%9B%B8%E4%BC%A0"><span class="toc-number">6.4.2.</span> <span class="toc-text">薪火相传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%AE%A2%E4%B8%BA%E4%B8%BB"><span class="toc-number">6.4.3.</span> <span class="toc-text">反客为主</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%EF%BC%88sentinel%EF%BC%89"><span class="toc-number">6.4.4.</span> <span class="toc-text">哨兵模式（sentinel）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">6.5.</span> <span class="toc-text">复制原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">6.6.</span> <span class="toc-text">复制的缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4"><span class="toc-number">6.7.</span> <span class="toc-text">命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E9%9B%86%E7%BE%A4"><span class="toc-number">7.</span> <span class="toc-text">Redis集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRedis%E9%9B%86%E7%BE%A4%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">什么是Redis集群？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA"><span class="toc-number">7.2.</span> <span class="toc-text">集群搭建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E5%91%BD%E4%BB%A4"><span class="toc-number">7.3.</span> <span class="toc-text">集群命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9"><span class="toc-number">7.4.</span> <span class="toc-text">节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SLOTS"><span class="toc-number">7.5.</span> <span class="toc-text">SLOTS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-Cluster%E5%8E%9F%E7%90%86"><span class="toc-number">7.6.</span> <span class="toc-text">Redis Cluster原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E9%9B%86%E7%BE%A4%E4%B8%AD%E5%BD%95%E5%85%A5%E5%80%BC-%E7%BB%84%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">7.7.</span> <span class="toc-text">在集群中录入值(组的概念)</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">D丶Cheng的博客</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 所有文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Redis-知识汇总</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-06-01T04:02:00.000Z" title="发表于 2020-06-01 12:02:00">2020-06-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-15T06:19:45.357Z" title="更新于 2021-12-15 14:19:45">2021-12-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Redis/">Redis</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><p>Redis：开源、免费、非关系型数据库、K-V数据库、内存数据库，支持持久化、事务和备份，集群(支持16个库)等高可用功能。并且性能极高(可以达到100000+的QPS)，易扩展，丰富的数据类型，所有操作都是单线程,原子性的。</p>
<p><strong>NOSQL</strong>：非关系型数据库，数据与数据之间没有关联关系。就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题</p>
<p>类型</p>
<ol>
<li>键值(key-value)存储数据库</li>
<li>列存储数据库：键仍然存在，但是指向了多个列，HBase (eg：博客平台(标签和文章)，日志)</li>
<li>文档型数据库 MongoDb  (eg：淘宝商品的评价)</li>
<li>图形数据库 Neo4j  （eg：好友列表）</li>
</ol>
<blockquote>
<p>扩展:</p>
<p>MongoDB是一个基于分布式文件存储的数据库。有C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。</p>
<p>MongoDB是一个介于关系型数据库和非关系型数据库之间的产品，是非关系数据库当中功能最丰富，最像关系型数据库的。</p>
<p>文档(document)是MongoDB中数据的基本单元，非常类似于关系型数据库系统中的行(但是比行要复杂的多);<br>集合(collection)就是一组文档，如果说MongoDB中的文档类似于关系型数据库中的行，那么集合就如同表;</p>
</blockquote>
<p>使用场景:</p>
<ol>
<li>数据模型比较简单</li>
<li>需要灵活更强的IT系统</li>
<li>对数据库性能要求比较高</li>
<li>不需要高度的数据一致性</li>
<li>对于给定的key，比较容易映射复杂值的环境</li>
</ol>
<p><strong>SQL</strong>:关系型数据库，表与表之间建立关联关系</p>
<h3 id="redis的安装"><a href="#redis的安装" class="headerlink" title="redis的安装"></a>redis的安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">拉取镜像</span></span><br><span class="line">docker pull redis</span><br><span class="line"><span class="meta">#</span><span class="bash">挂载数据卷并运行容器</span></span><br><span class="line">docker run -p 6379:6379 --name redis -v /root/redis/data:/data -v /root/redis/conf/redis.conf:/usr/local/etc/redis/redis.conf -d redis redis-server /usr/local/etc/redis/redis.conf --appendonly yes --requirepass &quot;xxx&quot;</span><br></pre></td></tr></table></figure>

<h3 id="为什么使用NOSQL"><a href="#为什么使用NOSQL" class="headerlink" title="为什么使用NOSQL"></a>为什么使用NOSQL</h3><h4 id="单机-MySQL-的美好时代"><a href="#单机-MySQL-的美好时代" class="headerlink" title="单机 MySQL 的美好时代"></a>单机 MySQL 的美好时代</h4><p>在90年代，一个网站的访问量一般都不大，用单个数据库完全可以轻松应付。<br> 在那个时候，更多的都是静态网页，动态交互类型的网站不多。</p>
<p><img src="https://img-blog.csdnimg.cn/20200326205200880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzY2ODgz,size_16,color_FFFFFF,t_70" alt="创建"></p>
<p>DAL : Data Access Layer（数据访问层 – Hibernate，MyBatis）</p>
<p>上述架构下，我们来看看<code>数据存储的瓶颈</code>是什么？</p>
<blockquote>
<ol>
<li>数据量的总大小一个机器放不下时。</li>
<li>数据的索引（B+ Tree）一个机器的内存放不下时。</li>
<li>访问量(读写混合)一个实例不能承受。</li>
</ol>
</blockquote>
<p>如果满足了上述1 or 3个时，只能对数据库的整体架构进行重构。</p>
<h4 id="Memcached-缓存-MySQL-垂直拆分"><a href="#Memcached-缓存-MySQL-垂直拆分" class="headerlink" title="Memcached(缓存)+MySQL+垂直拆分"></a>Memcached(缓存)+MySQL+垂直拆分</h4><p><a target="_blank" rel="noopener" href="http://codekiller.top/2020/03/29/mysql-split/">关于垂直拆分和水平拆分的简单介绍</a></p>
<p>后来，随着访问量的上升，几乎大部分使用MySQL架构的网站在数据库上都开始出现了性能问题，web程序不再仅仅专注在功能上，同时也在追求性能。程序员们开始大量的使用缓存技术来缓解数据库的压力，优化数据库的结构和索引。开始比较流行的是通过文件缓存来缓解数据库压力，但是当访问量继续增大的时候，多台web机器通过文件缓存不能共享，大量的小文件缓存也带了了比较高的IO压力。在这个时候，Memcached就自然的成为一个非常时尚的技术产品。</p>
<p><img src="https://img-blog.csdnimg.cn/20200326205550678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzY2ODgz,size_16,color_FFFFFF,t_70"></p>
<p>Memcached作为一个独立的分布式的缓存服务器，为多个web服务器提供了一个共享的高性能缓存服务，在Memcached服务器上，又发展了根据hash算法来进行多台Memcached缓存服务的扩展，然后又出现了一致性hash来解决增加或减少缓存服务器导致重新hash带来的大量缓存失效的弊端。</p>
<h4 id="Mysql主从读写分离"><a href="#Mysql主从读写分离" class="headerlink" title="Mysql主从读写分离"></a>Mysql主从读写分离</h4><p>由于数据库的写入压力增加，Memcached只能缓解数据库的读取压力。读写集中在一个数据库上让数据库不堪重负，大部分网站开始使用主从复制技术来达到读写分离，以提高读写性能和读库的可扩展性。Mysql的master-slave模式成为这个时候的网站标配了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/suolongY/warehouse@master/zk/format,png.png" alt="img"></p>
<h4 id="分库分表-水平拆分-mysql集群"><a href="#分库分表-水平拆分-mysql集群" class="headerlink" title="分库分表+水平拆分+mysql集群"></a>分库分表+水平拆分+mysql集群</h4><p>在Memcached的高速缓存，MySQL的主从复制，读写分离的基础之上，这时MySQL主库的写压力开始出现瓶颈，而数据量的持续猛增，由于MyISAM在写数据的时候会使用表锁，在高并发写数据的情况下会出现严重的锁问题，大量的高并发MySQL应用开始使用InnoDB引擎代替MyISAM。</p>
<blockquote>
<p>ps：这就是为什么 MySQL 在 5.6 版本之后使用 InnoDB 做为默认存储引擎的原因 – MyISAM 写会锁表，InnoDB 有行锁，，并且是事务优先，发生冲突的几率低，并发性能高。</p>
<p>注意锁的几个概念：行锁和表锁，读锁和写锁，乐观锁和悲观锁，还有一个间隙锁 </p>
<p>详情请看<a href="#http://codekiller.top/2020/03/27/mysql-lock/">锁的介绍</a></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200328165125982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzY2ODgz,size_16,color_FFFFFF,t_70"></p>
<h3 id="四种NoSQL对比"><a href="#四种NoSQL对比" class="headerlink" title="四种NoSQL对比"></a>四种NoSQL对比</h3><p><img src="https://img-blog.csdnimg.cn/20200328233415743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzY2ODgz,size_16,color_FFFFFF,t_70" alt="Nosql对比"></p>
<h3 id="3V-3高"><a href="#3V-3高" class="headerlink" title="3V+3高"></a>3V+3高</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">subgraph 互联网需求的3高</span><br><span class="line">3h((3高))--&gt;h1[高并发]</span><br><span class="line">3h--&gt;h2[高可用]</span><br><span class="line">3h--&gt;h3[高性能]</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subgraph 大数据时代的3V</span><br><span class="line">3v((3v))--&gt;V1[海量Volumn]</span><br><span class="line">3v--&gt;v2[多样Variety]</span><br><span class="line">3v--&gt;v3[实时Velocity]</span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><p>事务是由一组SQL语句组成的逻辑处理单元，事务具有4属性，通常称为事务的ACID属性。</p>
<ul>
<li><p><code>原子性</code>（Actomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</p>
</li>
<li><p><code>一致性</code>（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。</p>
<p>  eg：有3个人进行转账操作，为了保证一致性（即3个人 的账号金额总数不变），那在我写代码的时候，如果写了代码：A=A-5000;此时数据时不一致的。那就必须要写上，B=B+5000，或者是C=C+5000，这样的代码才能保证了数据库的一致性状态。</p>
</li>
<li><p><code>隔离性</code>（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。具体看下面的几个隔离级别和并发问题。</p>
</li>
<li><p><code>持久性</code>（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持</p>
</li>
</ul>
<h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><p>C：consistency，数据在多个副本中能保持一致的状态。</p>
<p>A：Availability，整个系统在任何时刻都能提供可用的服务，通常达到99.99%四个九可以称为<strong>高可用</strong></p>
<p>P：Partition tolerance，分区容错性，在分布式中，由于网络的原因无法避免有时候出现数据不一致的情况，系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择，换句话说，系统可以跨网络分区线性的伸缩和扩展。</p>
<p>CAP理论的核心：一个分布式系统<code>不可能同时</code>很好的满足一致性，可用性和分区容错性这三个需求，<code>最多只能同时较好的满足两个</code>。</p>
<ul>
<li>CA：单点集群，满足一致性，可用性的系统，通常在可扩展上不太强大。应用：传统的Oracle数据库</li>
<li>CP：满足一致性，分区容错性的系统，通常性能不是特别高。应用：Redis，MongoDB，银行</li>
<li>AP：满足可用性，分区容错性，通常可能对一致性要求低一些。应用：大多数网站架构的选择</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200329004954237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzY2ODgz,size_16,color_FFFFFF,t_70"></p>
<p>CAP理论就是说在分布式存储系统中，最多只能实现上面的两个。而由于当前的网络硬件肯定会出现延迟丢包等问题。所以</p>
<p><code>分区容忍性是我们必须需要实现的</code></p>
<p>所以我们只能在一致性和高可用之间进行权衡，没有NoSQL系统能同时保证三点。<a href="#sandian">为什么呢？</a></p>
<h3 id="为何CAP三者不可兼得"><a href="#为何CAP三者不可兼得" class="headerlink" title="为何CAP三者不可兼得"></a><span id="sandian">为何CAP三者不可兼得</span></h3><p>现在我们就来证明一下，为什么不能同时满足三个特性？</p>
<p>假设有两台服务器，一台放着应用A和数据库V，一台放着应用B和数据库V，他们之间的网络可以互通，也就相当于分布式系统的两个部分。</p>
<p>在满足一致性的时候，两台服务器 N1和N2，一开始两台服务器的数据是一样的，DB0=DB0。在满足可用性的时候，用户不管是请求N1或者N2，都会得到立即响应。在满足分区容错性的情况下，N1和N2有任何一方宕机，或者网络不通的时候，都不会影响N1和N2彼此之间的正常运作。           </p>
<p><img src="https://img-blog.csdnimg.cn/20200329012120473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzY2ODgz,size_16,color_FFFFFF,t_70"></p>
<p>当用户通过N1中的A应用请求数据更新到服务器DB0后，这时N1中的服务器DB0变为DB1，通过分布式系统的数据同步更新操作，N2服务器中的数据库V0也更新为了DB1，这时，用户通过B向数据库发起请求得到的数据就是即时更新后的数据DB1。</p>
<p>上面是正常运作的情况，但分布式系统中，最大的问题就是网络传输问题，现在假设一种极端情况，N1和N2之间的网络断开了，但我们仍要支持这种网络异常，也就是满足分区容错性，那么这样能不能同时满足一致性和可用性呢？</p>
<p><img src="https://img-blog.csdnimg.cn/20200329012231781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzY2ODgz,size_16,color_FFFFFF,t_70"></p>
<p>假设N1和N2之间通信的时候网络突然出现故障，有用户向N1发送数据更新请求，那N1中的数据DB0将被更新为DB1，由于网络是断开的，N2中的数据库仍旧是DB0；</p>
<p>如果这个时候，有用户向N2发送数据读取请求，由于数据还没有进行同步，应用程序没办法立即给用户返回最新的数据DB1，怎么办呢？有二种选择，第一，牺牲数据一致性，响应旧的数据DB0给用户；第二，牺牲可用性，阻塞等待，直到网络连接恢复，数据更新操作完成之后，再给用户响应最新的数据DB1。</p>
<p>上面的过程比较简单，但也说明了要满足分区容错性的分布式系统，只能在一致性和可用性两者中，选择其中一个。也就是说分布式系统不可能同时满足三个特性。这就需要我们在搭建系统时进行取舍了。</p>
<h3 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h3><p>Base就是为了解决关系型数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。</p>
<p>Base其实是下面三个术语的缩写：</p>
<ul>
<li>基本可用（Basically Available）</li>
<li>软状态（Soft state）状态可以有一段时间不同步</li>
<li>最终一致（Eventually consistent）最终数据是一致的就可以了，而不是时时保持强一致</li>
</ul>
<p>它的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观。为什么这么说呢，缘由就在于大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这些指标，要想获得这些指标，我们必须采用另外一种方式来完成，这里BASE就是解决这个问题的办法。</p>
<p>以<em>案例转账</em>为例，我们把用户A给用户B转账分成四个阶段，第一个阶段用户A准备转账，第二个阶段从用户A账户扣减余额，第三个阶段对用户B增加余额，第四个阶段完成转账。系统需要记录操作过程中每一步骤的状态，一旦系统出现故障，系统能够自动发现没有完成的任务，然后，根据任务所处的状态，继续执行任务，最终完成任务，达到一致的最终状态。</p>
<p>在实际应用中，上面这个过程通常是通过持久化执行任务的状态和环境信息，一旦出现问题，定时任务会捞取未执行完的任务，继续未执行完的任务，直到执行完成为止，或者取消已经完成的部分操作回到原始状态。这种方法在任务完成每个阶段的时候，都要更新数据库中任务的状态，这在大规模高并发系统中不会有太好的性能，一个更好的办法是用Write-Ahead Log（写前日志），这和数据库的Bin  Log（操作日志）相似，在做每一个操作步骤，都先写入日志，如果操作遇到问题而停止的时候，可以读取日志按照步骤进行恢复，并且继续执行未完成的工作，最后达到一致。写前日志可以利用机械硬盘的追加写而达到较好性能，因此，这是一种专业化的实现方式，多数业务系系统还是使用数据库记录的字段来记录任务的执行状态，也就是记录中间的“软状态”，一个任务的状态流转一般可以通过数据库的行级锁来实现，这比使用Write-Ahead Log实现更简单、更快速。</p>
<h3 id="分布式和集群"><a href="#分布式和集群" class="headerlink" title="分布式和集群"></a>分布式和集群</h3><p>分布式：不同的多台服务器上面部署不同的服务模块（工程）</p>
<p>集群：不同的多台服务器上面部署相同的服务模块。通过分布式调度软件进行统一的调度，对外提供服务和访问。</p>
<h2 id="解析配置文件"><a href="#解析配置文件" class="headerlink" title="解析配置文件"></a>解析配置文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">是否在后台运行；no：不是后台运行</span></span><br><span class="line">daemonize yes</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">是否开启保护模式，默认开启。要是配置里没有指定<span class="built_in">bind</span>和密码。开启该参数后，redis只会本地进行访问，拒绝外部访问。</span></span><br><span class="line">protected-mode yes</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">redis的进程文件</span></span><br><span class="line">pidfile /var/run/redis/redis-server.pid</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">redis监听的端口号。</span></span><br><span class="line">port 6379</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">此参数确定了TCP连接中已完成队列(完成三次握手之后)的长度， 当然此值必须不大于Linux系统定义的/proc/sys/net/core/somaxconn值，默认是511，而Linux的默认参数值是128。当系统并发量大并且客户端速度缓慢的时候，可以将这二个参数一起参考设定。该内核参数默认值一般是128，对于负载很大的服务程序来说大大的不够。一般会将它修改为2048或者更大。在/etc/sysctl.conf中添加:net.core.somaxconn = 2048，然后在终端中执行sysctl -p。</span></span><br><span class="line">tcp-backlog 511</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">指定 redis 只接收来自于该 IP 地址的请求，如果不进行设置，那么将处理所有请求</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">bind</span> 127.0.0.1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">bind</span> 0.0.0.0</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">配置unix socket来让redis支持监听本地连接。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> unixsocket /var/run/redis/redis.sock</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">配置unix socket使用文件的权限</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> unixsocketperm 700</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 此参数为设置客户端空闲超过timeout，服务端会断开连接，为0则服务端不会主动断开连接，不能小于0。</span></span><br><span class="line">timeout 0</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">tcp keepalive参数。如果设置不为0，就使用配置tcp的SO_KEEPALIVE值，使用keepalive有两个好处:检测挂掉的对端。降低中间设备出问题而导致网络看似连接却已经与对端端口的问题。在Linux内核中，设置了keepalive，redis会定时给对端发送ack。检测到对端关闭需要两倍的设置值。</span></span><br><span class="line">tcp-keepalive 0</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">指定了服务端日志的级别。级别包括：debug（很多信息，方便开发、测试），verbose（许多有用的信息，但是没有debug级别信息多），notice（适当的日志级别，适合生产环境），warn（只有非常重要的信息）</span></span><br><span class="line">loglevel notice</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">指定了记录日志的文件。空字符串的话，日志会打印到标准输出设备。后台运行的redis标准输出是/dev/null。</span></span><br><span class="line">logfile /var/log/redis/redis-server.log</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">是否打开记录syslog功能</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> syslog-enabled no</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">syslog的标识符。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> syslog-ident redis</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">日志的来源、设备</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> syslog-facility local0</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">数据库的数量，默认使用的数据库是DB 0。可以通过SELECT命令选择一个db</span></span><br><span class="line">databases 16</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> redis是基于内存的数据库，可以通过设置该值定期写入磁盘。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注释掉“save”这一行配置项就可以让保存数据库功能失效</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化） </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化） </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化）</span></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">当RDB持久化出现错误后，是否依然进行继续进行工作，yes：不能进行工作，no：可以继续进行工作，可以通过info中的rdb_last_bgsave_status了解RDB持久化是否有错误</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">使用压缩rdb文件，rdb文件压缩使用LZF压缩算法，yes：压缩，但是需要一些cpu的消耗。no：不压缩，需要更多的磁盘空间</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">是否校验rdb文件。从rdb格式的第五个版本开始，在rdb文件的末尾会带上CRC64的校验和。这跟有利于文件的容错性，但是在保存rdb文件的时候，会有大概10%的性能损耗，所以如果你追求高性能，可以关闭该配置。</span></span><br><span class="line">rdbchecksum yes</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">rdb文件的名称</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">数据目录，数据库的写入会在这个目录。rdb、aof文件也会写在这个目录</span></span><br><span class="line">dir /data</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">############## 主从复制 ###############</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">复制选项，slave复制对应的master。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> slaveof &lt;masterip&gt; &lt;masterport&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">如果master设置了requirepass，那么slave要连上master，需要有master的密码才行。masterauth就是用来配置master的密码，这样可以在连上master后进行认证。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> masterauth &lt;master-password&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">当从库同主机失去连接或者复制正在进行，从机库有两种运行方式：1) 如果slave-serve-stale-data设置为yes(默认设置)，从库会继续响应客户端的请求。2) 如果slave-serve-stale-data设置为no，除去INFO和SLAVOF命令之外的任何请求都会返回一个错误”SYNC with master <span class="keyword">in</span> progress”。</span></span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">作为从服务器，默认情况下是只读的（yes），可以修改成NO，用于写（不建议）。</span></span><br><span class="line">slave-read-only yes</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">是否使用socket方式复制数据。目前redis复制提供两种方式，disk和socket。如果新的slave连上来或者重连的slave无法部分同步，就会执行全量同步，master会生成rdb文件。有2种方式：disk方式是master创建一个新的进程把rdb文件保存到磁盘，再把磁盘上的rdb文件传递给slave。socket是master创建一个新的进程，直接把rdb文件以socket的方式发给slave。disk方式的时候，当一个rdb保存的过程中，多个slave都能共享这个rdb文件。socket的方式就的一个个slave顺序复制。在磁盘速度缓慢，网速快的情况下推荐用socket方式。</span></span><br><span class="line">repl-diskless-sync no</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">diskless复制的延迟时间，防止设置为0。一旦复制开始，节点不会再接收新slave的复制请求直到下一个rdb传输。所以最好等待一段时间，等更多的slave连上来。</span></span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">slave根据指定的时间间隔向服务器发送ping请求。时间间隔可以通过 repl_ping_slave_period 来设置，默认10秒。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> repl-ping-slave-period 10</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">复制连接超时时间。master和slave都有超时时间的设置。master检测到slave上次发送的时间超过repl-timeout，即认为slave离线，清除该slave信息。slave检测到上次和master交互的时间超过repl-timeout，则认为master离线。需要注意的是repl-timeout需要设置一个比repl-ping-slave-period更大的值，不然会经常检测到超时。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> repl-timeout 60</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">是否禁止复制tcp链接的tcp nodelay参数，可传递yes或者no。默认是no，即使用tcp nodelay。如果master设置了yes来禁止tcp nodelay设置，在把数据复制给slave的时候，会减少包的数量和更小的网络带宽。但是这也可能带来数据的延迟。默认我们推荐更小的延迟，但是在数据量传输很大的场景下，建议选择yes。</span></span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">复制缓冲区大小，这是一个环形复制缓冲区，用来保存最新复制的命令。这样在slave离线的时候，不需要完全复制master的数据，如果可以执行部分同步，只需要把缓冲区的部分数据复制给slave，就能恢复正常复制状态。缓冲区的大小越大，slave离线的时间可以更长，复制缓冲区只有在有slave连接的时候才分配内存。没有slave的一段时间，内存会被释放出来，默认1m。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> repl-backlog-size 5mb</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">master没有slave一段时间会释放复制缓冲区的内存，repl-backlog-ttl用来设置该时间长度。单位为秒。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> repl-backlog-ttl 3600</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">当master不可用，Sentinel会根据slave的优先级选举一个master。最低的优先级的slave，当选master。而配置成0，永远不会被选举。</span></span><br><span class="line">slave-priority 100</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">redis提供了可以让master停止写入的方式，如果配置了min-slaves-to-write，健康的slave的个数小于N，mater就禁止写入。master最少得有多少个健康的slave存活才能执行写命令。这个配置虽然不能保证N个slave都一定能接收到master的写操作，但是能避免没有足够健康的slave的时候，master不能写入来避免数据丢失。设置为0是关闭该功能。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> min-slaves-to-write 3</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">延迟小于min-slaves-max-lag秒的slave才认为是健康的slave。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> min-slaves-max-lag 10</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置1或另一个设置为0禁用这个特性。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Setting one or the other to 0 disables the feature.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> By default min-slaves-to-write is <span class="built_in">set</span> to 0 (feature disabled) and</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> min-slaves-max-lag is <span class="built_in">set</span> to 10.</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">############## 安全相关 ###############</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">requirepass配置可以让用户使用AUTH命令来认证密码，才能使用其他命令。这让redis可以使用在不受信任的网络中。为了保持向后的兼容性，可以注释该命令，因为大部分用户也不需要认证。使用requirepass的时候需要注意，因为redis太快了，每秒可以认证15w次密码，简单的密码很容易被攻破，所以最好使用一个更复杂的密码。注意只有密码没有用户名。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> requirepass foobared</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">把危险的命令给修改成其他名称。比如CONFIG命令可以重命名为一个很难被猜到的命令，这样用户不能使用，而内部工具还能接着使用。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">设置成一个空的值，可以禁止一个命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> rename-command CONFIG <span class="string">&quot;&quot;</span></span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">############## 进程限制相关 ###############</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置能连上redis的最大客户端连接数量。默认是10000个客户端连接。由于redis不区分连接是客户端连接还是内部打开文件或者和slave连接等，所以maxclients最小建议设置到32。如果超过了maxclients，redis会给新的连接发送’max number of clients reached’，并关闭连接。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> maxclients 10000</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">redis配置的最大内存容量。当内存满了，需要配合maxmemory-policy策略进行处理。注意slave的输出缓冲区是不计算在maxmemory内的。所以为了防止主机内存使用完，建议设置的maxmemory需要更小一些。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> maxmemory &lt;bytes&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">内存容量超过maxmemory后的处理策略。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">volatile-lru：利用LRU算法移除设置过过期时间的key。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">volatile-random：随机移除设置过过期时间的key。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">volatile-ttl：移除即将过期的key，根据最近过期时间来删除（辅以TTL）</span></span><br><span class="line"><span class="meta">#</span><span class="bash">allkeys-lru：利用LRU算法移除任何key。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">allkeys-random：随机移除任何key。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">noeviction：不移除任何key，只是返回一个写错误。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">上面的这些驱逐策略，如果redis没有合适的key驱逐，对于写命令，还是会返回错误。redis将不再接收写请求，只接收get请求。写命令包括：<span class="built_in">set</span> setnx setex append incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby getset mset msetnx <span class="built_in">exec</span> sort。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> maxmemory-policy noeviction</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">lru检测的样本数。使用lru或者ttl淘汰算法，从需要淘汰的列表中随机选择sample个key，选出闲置时间最长的key移除。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> maxmemory-samples 5</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">############## APPEND ONLY 持久化方式 ###############</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">默认redis使用的是rdb方式持久化，这种方式在许多应用中已经足够用了。但是redis如果中途宕机，会导致可能有几分钟的数据丢失，根据save来策略进行持久化，Append Only File是另一种持久化方式，可以提供更好的持久化特性。Redis会把每次写入的数据在接收后都写入 appendonly.aof 文件，每次启动时Redis都会先把这个文件的数据读入内存里，先忽略RDB文件。</span></span><br><span class="line">appendonly no</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">aof文件名</span></span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">aof持久化策略的配置</span></span><br><span class="line"><span class="meta">#</span><span class="bash">no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">always表示每次写入都执行fsync，以保证数据同步到磁盘。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 在aof重写或者写入rdb文件的时候，会执行大量IO，此时对于everysec和always的aof模式来说，执行fsync会造成阻塞过长时间，no-appendfsync-on-rewrite字段设置为默认设置为no，是最安全的方式，不会丢失数据，但是要忍受阻塞的问题。如果对延迟要求很高的应用，这个字段可以设置为yes，，设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,不会造成阻塞的问题（因为没有磁盘竞争），等rewrite完成后再写入，这个时候redis会丢失数据。Linux的默认fsync策略是30秒。可能丢失30秒数据。因此，如果应用系统无法忍受延迟，而可以容忍少量的数据丢失，则设置为yes。如果应用系统无法忍受数据丢失，则设置为no。</span></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">aof自动重写配置。当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候Redis能够调用bgrewriteaof对日志文件进行重写。当前AOF文件大小是上次日志重写得到AOF文件大小的二倍（设置为100）时，自动启动新的日志重写过程。</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"><span class="meta">#</span><span class="bash">设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">aof文件可能在尾部是不完整的，当redis启动的时候，aof文件的数据被载入内存。重启可能发生在redis所在的主机操作系统宕机后，尤其在ext4文件系统没有加上data=ordered选项（redis宕机或者异常终止不会造成尾部不完整现象。）出现这种现象，可以选择让redis退出，或者导入尽可能多的数据。如果选择的是yes，当截断的aof文件被导入的时候，会自动发布一个<span class="built_in">log</span>给客户端然后load。如果是no，用户必须手动redis-check-aof修复AOF文件才可以。</span></span><br><span class="line">aof-load-truncated yes</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">############## LUA SCRIPTING ###############</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果达到最大时间限制（毫秒），redis会记个<span class="built_in">log</span>，然后返回error。当一个脚本超过了最大时限。只有SCRIPT KILL和SHUTDOWN NOSAVE可以用。第一个可以杀没有调write命令的东西。要是已经调用了write，只能用第二个命令杀。</span></span><br><span class="line">lua-time-limit 5000</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">############## 集群相关 ###############</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">集群开关，默认是不开启集群模式。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cluster-enabled yes</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">集群配置文件的名称，每个节点都有一个集群相关的配置文件，持久化保存集群的信息。这个文件并不需要手动配置，这个配置文件有Redis生成并更新，每个Redis集群节点需要一个单独的配置文件，请确保与实例运行的系统中配置文件名称不冲突</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cluster-config-file nodes-6379.conf</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">节点互连超时的阀值。集群节点超时毫秒数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cluster-node-timeout 15000</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">在进行故障转移的时候，全部slave都会请求申请为master，但是有些slave可能与master断开连接一段时间了，导致数据过于陈旧，这样的slave不应该被提升为master。该参数就是用来判断slave节点与master断线的时间是否过长。判断方法是：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">比较slave断开连接的时间和(node-timeout * slave-validity-factor) + repl-ping-slave-period</span></span><br><span class="line"><span class="meta">#</span><span class="bash">如果节点超时时间为三十秒, 并且slave-validity-factor为10,假设默认的repl-ping-slave-period是10秒，即如果超过310秒slave将不会尝试进行故障转移 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cluster-slave-validity-factor 10</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">master的slave数量大于该值，slave才能迁移到其他孤立master上，如这个参数若被设为2，那么只有当一个主节点拥有2 个可工作的从节点时，它的一个从节点会尝试迁移。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cluster-migration-barrier 1</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">默认情况下，集群全部的slot有节点负责，集群状态才为ok，才能提供服务。设置为no，可以在slot没有全部分配的时候提供服务。不建议打开该配置。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cluster-require-full-coverage yes</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">############## SLOW LOG 慢查询日志 ###############</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##slog log是用来记录redis运行中执行比较慢的命令耗时。当命令的执行超过了指定时间，就记录在slow log中，slog log保存在内存中，所以没有IO操作。</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">执行时间比slowlog-log-slower-than大的请求记录到slowlog里面，单位是微秒，所以1000000就是1秒。注意，负数时间会禁用慢查询日志，而0则会强制记录所有命令。</span></span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">慢查询日志长度。当一个新的命令被写进日志的时候，最老的那个记录会被删掉。这个长度没有限制。只要有足够的内存就行。你可以通过 SLOWLOG RESET 来释放内存。</span></span><br><span class="line">slowlog-max-len 128</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">############## 延迟监控 ###############</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">延迟监控功能是用来监控redis中执行比较缓慢的一些操作，用LATENCY打印redis实例在跑命令时的耗时图表。只记录大于等于下边设置的值的操作。0的话，就是关闭监视。默认延迟监控功能是关闭的，如果你需要打开，也可以通过CONFIG SET命令动态设置。</span></span><br><span class="line">latency-monitor-threshold 0</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">############## EVENT NOTIFICATION 订阅通知 ###############</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">键空间通知使得客户端可以通过订阅频道或模式，来接收那些以某种方式改动了 Redis 数据集的事件。因为开启键空间通知功能需要消耗一些 CPU ，所以在默认配置下，该功能处于关闭状态。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">notify-keyspace-events 的参数可以是以下字符的任意组合，它指定了服务器该发送哪些类型的通知：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#K 键空间通知，所有通知以 __keyspace@__ 为前缀</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#E 键事件通知，所有通知以 __keyevent@__ 为前缀</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#g DEL 、 EXPIRE 、 RENAME 等类型无关的通用命令的通知</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#$ 字符串命令的通知</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#l 列表命令的通知</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#s 集合命令的通知</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#h 哈希命令的通知</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#z 有序集合命令的通知</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#x 过期事件：每当有过期键被删除时发送</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#e 驱逐(evict)事件：每当有键因为 maxmemory 政策而被删除时发送</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#A 参数 g$lshzxe 的别名</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">输入的参数中至少要有一个 K 或者 E，否则的话，不管其余的参数是什么，都不会有任何 通知被分发。详细使用可以参考http://redis.io/topics/notifications</span></span><br><span class="line"> </span><br><span class="line">notify-keyspace-events &quot;&quot;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">############## ADVANCED CONFIG 高级配置 ###############</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">数据量小于等于hash-max-ziplist-entries的用ziplist，大于hash-max-ziplist-entries用<span class="built_in">hash</span></span></span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line"><span class="meta">#</span><span class="bash">value大小小于等于hash-max-ziplist-value的用ziplist，大于hash-max-ziplist-value用<span class="built_in">hash</span>。</span></span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">数据量小于等于list-max-ziplist-entries用ziplist，大于list-max-ziplist-entries用list。</span></span><br><span class="line">list-max-ziplist-entries 512</span><br><span class="line"><span class="meta">#</span><span class="bash">value大小小于等于list-max-ziplist-value的用ziplist，大于list-max-ziplist-value用list。</span></span><br><span class="line">list-max-ziplist-value 64</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">数据量小于等于set-max-intset-entries用iniset，大于set-max-intset-entries用<span class="built_in">set</span>。</span></span><br><span class="line">set-max-intset-entries 512</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">数据量小于等于zset-max-ziplist-entries用ziplist，大于zset-max-ziplist-entries用zset。</span></span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line"><span class="meta">#</span><span class="bash">value大小小于等于zset-max-ziplist-value用ziplist，大于zset-max-ziplist-value用zset。</span></span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">value大小小于等于hll-sparse-max-bytes使用稀疏数据结构（sparse），大于hll-sparse-max-bytes使用稠密的数据结构（dense）。一个比16000大的value是几乎没用的，建议的value大概为3000。如果对CPU要求不高，对空间要求较高的，建议设置到10000左右。</span></span><br><span class="line">hll-sparse-max-bytes 3000</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">Redis将在每100毫秒时使用1毫秒的CPU时间来对redis的<span class="built_in">hash</span>表进行重新<span class="built_in">hash</span>，可以降低内存的使用。当你的使用场景中，有非常严格的实时性需要，不能够接受Redis时不时的对请求有2毫秒的延迟的话，把这项配置为no。如果没有这么严格的实时性要求，可以设置为yes，以便能够尽可能快的释放内存。</span></span><br><span class="line">activerehashing yes</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#对客户端输出缓冲进行限制可以强迫那些不从服务器读取数据的客户端断开连接，用来强制关闭传输缓慢的客户端。</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">对于normal client，第一个0表示取消hard <span class="built_in">limit</span>，第二个0和第三个0表示取消soft <span class="built_in">limit</span>，normal client默认取消限制，因为如果没有寻问，他们是不会接收数据的。</span></span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line"><span class="meta">#</span><span class="bash">对于slave client和MONITER client，如果client-output-buffer一旦超过256mb，又或者超过64mb持续60秒，那么服务器就会立即断开客户端连接。</span></span><br><span class="line">client-output-buffer-limit slave 256mb 64mb 60</span><br><span class="line"><span class="meta">#</span><span class="bash">对于pubsub client，如果client-output-buffer一旦超过32mb，又或者超过8mb持续60秒，那么服务器就会立即断开客户端连接。</span></span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">redis执行任务的频率为1s除以hz。</span></span><br><span class="line">hz 10</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">在aof重写的时候，如果打开了aof-rewrite-incremental-fsync开关，系统会每32MB执行一次fsync。这对于把文件写入磁盘是有帮助的，可以避免过大的延迟峰值。</span></span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure>

<h2 id="Redis的持久化"><a href="#Redis的持久化" class="headerlink" title="Redis的持久化"></a>Redis的持久化</h2><h2 id="Redis的事务"><a href="#Redis的事务" class="headerlink" title="Redis的事务"></a>Redis的事务</h2><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><p>可以一次执行多个命令，本质是一组命令的集合。一个事物中的所有命令都会被序列化，按顺序的串行执行而不会被其他命令插入，不许加塞。</p>
<h3 id="能干嘛？"><a href="#能干嘛？" class="headerlink" title="能干嘛？"></a>能干嘛？</h3><p>一个队列中，一次性的，顺序的，排他的执行一系列命令。</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>multi</td>
<td>标记一个事务的开始</td>
</tr>
<tr>
<td>exec</td>
<td>执行所有事务块内的命令</td>
</tr>
<tr>
<td>discard</td>
<td>取消事务，放弃执行事务块内的所有命令</td>
</tr>
<tr>
<td>watch key [key]</td>
<td>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</td>
</tr>
<tr>
<td>unwatch</td>
<td>取消watch命令对所有 key 的监视。</td>
</tr>
</tbody></table>
<h3 id="这么玩？"><a href="#这么玩？" class="headerlink" title="这么玩？"></a>这么玩？</h3><ol>
<li><p><strong>正常执行</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200329153535143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzY2ODgz,size_16,color_FFFFFF,t_70"></p>
</li>
<li><p><strong>放弃事务</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200329153617123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzY2ODgz,size_16,color_FFFFFF,t_70"></p>
</li>
<li><p><strong>全体连坐</strong></p>
<p><img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20200329153701009.png"></p>
</li>
<li><p><span id="yuan"><b>冤头债主</b></span></p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200329153742186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzY2ODgz,size_16,color_FFFFFF,t_70"></p>
<h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><p><a target="_blank" rel="noopener" href="http://codekiller.top/2020/03/27/mysql-lock/#toc-heading-24">参考</a></p>
<h3 id="Watch监控"><a href="#Watch监控" class="headerlink" title="Watch监控"></a>Watch监控</h3><p>watch指令，<code>类似乐观锁</code>，如果key的值已经被修改了，那么<strong>整个事务队列都不会被执行</strong>,同时返回一个Nullmulti-bulk应答以通知调用者事务执行失败。</p>
<p>注意：<strong>一旦执行了exec或者discard，之前加的所有监控锁都会被取消掉了。</strong></p>
<p>例子：</p>
<ul>
<li><p>初始化信用卡的可用余额和欠额</p>
<p><img src="https://img-blog.csdnimg.cn/2020032915483754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzY2ODgz,size_16,color_FFFFFF,t_70"></p>
</li>
<li><p>无加塞篡改</p>
<p><img src="https://img-blog.csdnimg.cn/20200329154925759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzY2ODgz,size_16,color_FFFFFF,t_70"></p>
</li>
<li><p>有加塞篡改，当watch的key被修改，后面的那个事务全部执行失败</p>
<p><img src="https://img-blog.csdnimg.cn/20200329155110938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzY2ODgz,size_16,color_FFFFFF,t_70"></p>
</li>
<li><p>unwatch</p>
<p><img src="https://img-blog.csdnimg.cn/20200329155227451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzY2ODgz,size_16,color_FFFFFF,t_70"></p>
</li>
</ul>
<h3 id="3阶段"><a href="#3阶段" class="headerlink" title="3阶段"></a>3阶段</h3><p>开启:以multi开启事务</p>
<p>入队:将多个命令入队到事务中,接到这些命令不会立刻执行,而是放到等待执行的事务队列里面</p>
<p>执行：有exec命令触发事务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR </span><br><span class="line">kai((开启))&#x3D;&#x3D;&gt;ru((入队))</span><br><span class="line">ru&#x3D;&#x3D;&gt;zhi((执行))</span><br></pre></td></tr></table></figure>

<h3 id="3特性"><a href="#3特性" class="headerlink" title="3特性"></a>3特性</h3><p>单独的隔离操作：事务中的所有命令都会序列化，按顺序的执行。事务在等待执行的时候，不会被其他客户端发送来的米命令请求打断</p>
<p>没有隔离级别的概念：队列中的所有命令没有提交exec之前都是不会被执行的</p>
<p>不保证原子性：redis中如果一条命令执行失败，其后的命令仍然会被执行，没有回滚，参考<a href="#yuan">冤头债主</a></p>
<h2 id="Redis的发布订阅-一般不用"><a href="#Redis的发布订阅-一般不用" class="headerlink" title="Redis的发布订阅(一般不用)"></a>Redis的发布订阅(一般不用)</h2><h4><a id="_228"></a>发布订阅</h4>
<p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p>
<p>Redis 客户端可以订阅任意数量的频道。</p>
<p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：<br>
<img src="https://img-blog.csdnimg.cn/20190925161943181.png" alt=""><br/><br/>
当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：<br/>
<img src="https://img-blog.csdnimg.cn/20190925161952995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNDIzNDE4,size_16,color_FFFFFF,t_70" alt=""><br/><br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em><strong>命令</strong></em></p>
<blockquote>
<ul>
<li>subscribe channel [channel…]：订阅一个或多个频道的信息</li>
<li>psubscribe pattern [pattern…]：订阅一个或多个符合规定模式的频道</li>
<li>publish channel message ：将信息发送到指定频道</li>
<li>unsubscribe [channel[channel…]]：退订频道</li>
<li>punsubscribe [pattern[pattern…]]：退订所有给定模式的频道</li>
</ul>
</blockquote><br/>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em><strong>应用场景</strong></em></p>
<blockquote>
构建实时的消息系统，比如普通聊天、群聊等功能。
1、博客网站订阅，当作者发布就可以推送给粉丝
2、微信公众号模式
</blockquote>



<h2 id="Redis的复制（Master-Slave）"><a href="#Redis的复制（Master-Slave）" class="headerlink" title="Redis的复制（Master/Slave）"></a>Redis的复制（Master/Slave）</h2><h3 id="是什么？-1"><a href="#是什么？-1" class="headerlink" title="是什么？"></a>是什么？</h3><p>​    就是我们常说的主从复制，主机数据更新后根据配置和策略，自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主</p>
<h3 id="能干嘛？-1"><a href="#能干嘛？-1" class="headerlink" title="能干嘛？"></a>能干嘛？</h3><p>​    <code>读写分离</code></p>
<p>​     <code>容灾恢复</code></p>
<h3 id="怎么玩？"><a href="#怎么玩？" class="headerlink" title="怎么玩？"></a>怎么玩？</h3><p>配从(库)不配主(库)</p>
<p>从库配置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">配置从库</span></span><br><span class="line">slaveof 主库ip 主库端口</span><br><span class="line"><span class="meta">#</span><span class="bash">查看主从信息</span></span><br><span class="line">info replication</span><br></pre></td></tr></table></figure>

<p>​        每次与master断开后，都需要重新连接，除非你配置进redis.conf文件</p>
<h3 id="常用的主从方式"><a href="#常用的主从方式" class="headerlink" title="常用的主从方式"></a>常用的主从方式</h3><h4 id="一主二仆"><a href="#一主二仆" class="headerlink" title="一主二仆"></a>一主二仆</h4><p>含义：就是一个Master两个Slave</p>
<p><img src="https://cdn.jsdelivr.net/gh/suolongY/warehouse@master/zk/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzY2ODgz,size_16,color_FFFFFF,t_70.png" alt="一仆二主"></p>
<p>通过<code>info replication</code>查看主从信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:f6baff9abfda12ca58048cfce4b0e2c1f4683da1</span><br><span class="line">master_replid2:e8fe596d47d9d1d923d56d884b28128b78d2c1e0</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:down</span><br><span class="line">master_last_io_seconds_ago:-1</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:0</span><br><span class="line">master_link_down_since_seconds:1585217521</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:adbec19afa734e84a333b07ea2f33c43c73fe743</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure>



<p><span id="zhuyi">注意:</span></p>
<ol>
<li><p>第一次slave1 和slave2切入点，是全量复制，之后是增量复制</p>
<p><img src="https://cdn.jsdelivr.net/gh/suolongY/warehouse@master/zk/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzY2ODgz,size_16,color_FFFFFF,t_70-20201122134433424.png" alt="一主二仆"></p>
</li>
<li><p>主机可以写，但是从机不可以写，从机只能读</p>
<p><img src="https://img-blog.csdnimg.cn/20200326181813787.png" alt="从机写的报错"></p>
</li>
<li><p>主机shutdowm后从机待机状态，等主机回来后，主机新增记录从机可以顺利复制 </p>
</li>
<li><p>从机shutdowm后，每次与master断开之后，都需要重新连接，除非你配置进redis.conf文件</p>
</li>
<li><p>从机复制到的数据，会被本机持久化。就算shutdown断开连接依然会有数据。</p>
</li>
<li><p>重新连接或者变更master，会清除之前的数据，重新建立拷贝最新的数据</p>
</li>
</ol>
<h4 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h4><p>含义:就是上一个Slave可以是下一个slave的Master，Slave同样可以接收其他slaves的连接和同步请求，那么该slave作为了链条中下一个的master,可以有效减轻master的写压力。</p>
<p><img src="https://img-blog.csdnimg.cn/20200326185522463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzY2ODgz,size_16,color_FFFFFF,t_70" alt="薪火相传"></p>
<p><code>注意事项和一主二仆差不多,但注意虽然有slave是相对master，但是依然是slave</code>    [查看](#zhu yi)</p>
<h4 id="反客为主"><a href="#反客为主" class="headerlink" title="反客为主"></a>反客为主</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLAVEOF no one</span><br></pre></td></tr></table></figure>

<p> 使当前数据库停止与其他数据库的同步，转成主数据库</p>
<h4 id="哨兵模式（sentinel）"><a href="#哨兵模式（sentinel）" class="headerlink" title="哨兵模式（sentinel）"></a>哨兵模式（sentinel）</h4><p>反客为主的自动版，能够后台监控Master库是否故障，如果故障了根据投票数自动将slave库转换为主库。一组sentinel能</p>
<p>同时监控多个Master。</p>
<p>使用步骤：</p>
<ol>
<li><p>在Master对应redis.conf同目录下新建sentinel.conf文件，名字绝对不能错；</p>
</li>
<li><p>配置哨兵，在sentinel.conf文件中填入内容(可以配置多个)：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">说明：最后一个数字1，表示主机挂掉后slave投票看让谁接替成为主机，得票数多少后成为主机。</span></span><br><span class="line">sentinel monitor 被监控数据库名字（自己起名字） ip port 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动哨兵模式(路径按照自己的需求进行配置)：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel  /myredis/sentinel.conf</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>注意：</p>
<ol>
<li><p>当master挂掉后，会通过选票进行选出下一个master。而且只有使用了sentinel.conf启动的才能开启选票</p>
</li>
<li><p>当原来的master后来后，很不幸变成了slave。</p>
</li>
</ol>
<h3 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h3><ol>
<li><p>Slave启动成功连接到master后会发送一个sync命令；</p>
</li>
<li><p>Master接到命令启动后的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master</p>
<p>将传送整个数据文件到slave，以完成一次完全同步；</p>
</li>
<li><p><code>全量复制</code>：而slave服务在数据库文件数据后，将其存盘并加载到内存中；</p>
</li>
<li><p><code>增量复制</code>：Master继续将新的所有收集到的修改命令依次传给slave，完成同步；</p>
</li>
<li><p>但是只要是重新连接master，一次完全同步（全量复制）将被自动执行。</p>
<p>[结合这几个注意事项](#zhu yi)</p>
</li>
</ol>
<h3 id="复制的缺点"><a href="#复制的缺点" class="headerlink" title="复制的缺点"></a>复制的缺点</h3><p>​       延时，由于所有的写操作都是在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使得这个问题更加严重。</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>slaveof 主库ip  主库端口</td>
<td>配置从库</td>
</tr>
<tr>
<td>info replication</td>
<td>查看redis主从复制的情况</td>
</tr>
<tr>
<td>slaveof  no one</td>
<td>使当前数据库停止与其他数据库的同步，转成主数据库</td>
</tr>
<tr>
<td>sentinel monitor 被监控数据库名字(自己起名字) 127.0.0.1 6379 1</td>
<td>配置哨兵，监视master</td>
</tr>
<tr>
<td>redis-sentinel /myredis/sentinel.conf</td>
<td>以哨兵模式启动redis</td>
</tr>
</tbody></table>
<h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><p>容量不够，redis如何扩容？</p>
<p>并发写操作，redis如何分摊？</p>
<h3 id="什么是Redis集群？"><a href="#什么是Redis集群？" class="headerlink" title="什么是Redis集群？"></a>什么是Redis集群？</h3><p>Redis集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N</p>
<p>Redis集群通过分区（partition）来提供一定程度的可用性（availability）：即使集群中有一部分节点失效或者无法进行通讯，集群也可以继续处理命令请求。</p>
<h3 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h3><p><a target="_blank" rel="noopener" href="http://codekiller.top/2020/03/30/redis-cluster/">搭建看这篇文章,有效</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">yi((导入安装包))--&gt;er((修改配置文件))</span><br><span class="line">er((修改配置文件))--&gt;san((创建基本镜像))</span><br><span class="line">san--&gt;si((创建节点镜像))</span><br><span class="line">si--&gt;|启动6个容器|wu((进入一个redis-cli))</span><br><span class="line">wu--&gt;|cluster meet|liu((集群添加节点))</span><br><span class="line">liu--&gt;qi((配置槽点))</span><br><span class="line">qi--&gt;ba((配置主从高可用))</span><br></pre></td></tr></table></figure>





<h3 id="集群命令"><a href="#集群命令" class="headerlink" title="集群命令"></a>集群命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER INFO 打印集群的信息 </span><br><span class="line">CLUSTER NODES 列出集群当前已知的所有节点（node），以及这些节点的相关信息。  </span><br><span class="line"></span><br><span class="line">//节点(node) </span><br><span class="line">CLUSTER MEET &lt;ip&gt; &lt;port&gt; 将 ip 和 port 所指定的节点添加到集群当中，让它成为集群的一份子。 </span><br><span class="line">CLUSTER FORGET &lt;node_id&gt; 从集群中移除 node_id 指定的节点。 </span><br><span class="line">CLUSTER REPLICATE &lt;node_id&gt; 将当前节点设置为 node_id 指定的节点的从节点。 </span><br><span class="line">CLUSTER SAVECONFIG 将节点的配置文件保存到硬盘里面。  </span><br><span class="line"></span><br><span class="line">//槽(slot) </span><br><span class="line">CLUSTER ADDSLOTS &lt;slot&gt; [slot ...] 将一个或多个槽（slot）指派（assign）给当前节点。 </span><br><span class="line">CLUSTER DELSLOTS &lt;slot&gt; [slot ...] 移除一个或多个槽对当前节点的指派。 </span><br><span class="line">CLUSTER FLUSHSLOTS 移除指派给当前节点的所有槽，让当前节点变成一个没有指派任何槽的节点。 </span><br><span class="line">CLUSTER SETSLOT &lt;slot&gt; NODE &lt;node_id&gt; 将槽 slot 指派给 node_id 指定的节点，如果槽已经指派给另一个节点，那么先让另一个节点删除该槽&gt;，然后再进行指派。 </span><br><span class="line">CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;node_id&gt; 将本节点的槽 slot 迁移到 node_id 指定的节点中。 </span><br><span class="line">CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;node_id&gt; 从 node_id 指定的节点中导入槽 slot 到本节点。 </span><br><span class="line">CLUSTER SETSLOT &lt;slot&gt; STABLE 取消对槽 slot 的导入（import）或者迁移（migrate）。  </span><br><span class="line"></span><br><span class="line">//键 (key) </span><br><span class="line">CLUSTER KEYSLOT &lt;key&gt; 计算键 key 应该被放置在哪个槽上。 </span><br><span class="line">CLUSTER COUNTKEYSINSLOT &lt;slot&gt; 返回槽 slot 目前包含的键值对数量。 </span><br><span class="line">CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt; 返回 count 个 slot 槽中的键。</span><br></pre></td></tr></table></figure>



<h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><ol>
<li><p>一个集群至少要有三个主节点，即要有六个节点。</p>
</li>
<li><p>分配原则尽量保证每个主数据库运行在不同的ip地址，每个从库和主库不在一个ip地址。</p>
</li>
<li><p>当主节点崩了，从节点能自动升为主节点；当主节点再次恢复时，主节点变为slave。参考哨兵模式。</p>
</li>
<li><p>redis.conf有个参数cluster-require-full-coverage</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">默认情况下，集群全部的slot有节点负责，集群状态才为ok，才能提供服务。设置为no，可以在slot没有全部分配的时候提供服务。不建议打开该配置。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cluster-require-full-coverage yes</span></span><br></pre></td></tr></table></figure>







</li>
</ol>
<h3 id="SLOTS"><a href="#SLOTS" class="headerlink" title="SLOTS"></a>SLOTS</h3><ul>
<li><p>一个Redis 集群包含16384个插槽(hash slot)， 数据库中的每个键都属于这16384个插槽的其中一个，集群使用公式CRC1 6(key)% 16384来计算键key属于哪个槽(如果有组的话就只算组的部分)，其中<code>CRC16(key)</code>语句用于计算键key的CRC16校验和。</p>
</li>
<li><p>集群中的每个节点负责处理一部分插槽。 举个例子， 如果一个集群可以有主节点。其中:</p>
<ul>
<li>节点A负责处理0号至5500号插槽</li>
<li>节点B负责处理5501号至11000号插槽</li>
<li>节点C负责处理11001号至16383号插槽</li>
</ul>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(注意：每个节点分配的插槽具体数字可能不同，当然可以通过一个小脚本来指定)</p>
<p><strong>一个疑问：为什么是16384(2^14)，而不是65535(2^16)呢？</strong></p>
<p>在redis节点发送心跳包时需要把所有的槽放到这个心跳包里，以便让节点知道当前集群信息，16384=16k，在发送心跳包时使用char进行bitmap压缩后是2kb（16384÷8÷1024=2kb），也就是说使用2k的空间创建了16k的槽数65535=65k，压缩后就是8kb（65536÷8÷1024=8kb），也就是说需要需要8k的心跳包。</p>
<h3 id="Redis-Cluster原理"><a href="#Redis-Cluster原理" class="headerlink" title="Redis Cluster原理"></a>Redis Cluster原理</h3><ol>
<li>node1和node2首先进行握手meet，知道彼此的存在</li>
<li>握手成功后，两个节点会定期发送ping/pong消息，交换数据信息(消息头，消息体)</li>
<li>消息头里面有个字段：unsigned char myslots[CLUSTER_SLOTS/8]，每一位代表一个槽，如果该位是1，代表该槽属于这个节点</li>
<li>消息体中会携带一定数量的其他节点的信息，大约占集群节点总数量的十分之一，至少是3个节点的信息。节点数量越多，消息体内容越大。</li>
<li>每秒都在发送ping消息。每秒随机选取5个节点，找出最久没有通信的节点发送ping消息。</li>
<li>每100毫秒都会扫描本地节点列表，如果发现节点最近一次接受pong消息的时间大于cluster-node-timeout/2,则立即发送ping消息</li>
</ol>
<p>redis集群的主节点数量基本不可能超过1000个，超过的话可能会导致网络拥堵。</p>
<h3 id="在集群中录入值-组的概念"><a href="#在集群中录入值-组的概念" class="headerlink" title="在集群中录入值(组的概念)"></a>在集群中录入值(组的概念)</h3><p>redis-cli客户端提供-c参数实现自动重定向</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c -p 6379</span><br></pre></td></tr></table></figure>

<p>不在一个slot下的键值，是不能使用mget，mset等多键操作</p>
<p>可以通过{}来定义<code>组的概念</code>，从而使key中{}内相同内容的键值对放到一个slot中去。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">set user:&#123;info&#125;:name xxx</span><br><span class="line">set age&#123;info&#125; 12</span><br><span class="line">set &#123;info&#125;email 12345@qq.com</span><br><span class="line">hset user&#123;info&#125; name jiang</span><br><span class="line">hset user&#123;info&#125; age 19</span><br><span class="line">hset user&#123;info&#125; eamil 12345@qq.com</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">结果</span></span><br><span class="line">172.17.0.3:6379&gt; keys *</span><br><span class="line">1) &quot;user&#123;info&#125;&quot;</span><br><span class="line">2) &quot;&#123;info&#125;email&quot;</span><br><span class="line">3) &quot;user:&#123;info&#125;:name&quot;</span><br><span class="line">4) &quot;age&#123;info&#125;&quot;</span><br><span class="line">------------------------------------------------------</span><br><span class="line">172.17.0.3:6379&gt; hkeys user&#123;info&#125;</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;age&quot;</span><br><span class="line">3) &quot;eamil&quot;</span><br></pre></td></tr></table></figure>

</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">D丶Cheng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://chave-z.github.io/posts/af9b4eba.html">https://chave-z.github.io/posts/af9b4eba.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://chave-z.github.io" target="_blank">D丶Cheng的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post_share"><div class="social-share" data-image="/null" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/fe29e710.html"><img class="prev-cover" src="/null" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis基础</div></div></a></div><div class="next-post pull-right"><a href="/posts/207e4c9d.html"><img class="next-cover" src="/null" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Redis学习目录</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/b7e51ad7.html" title="Redis主从复制"><img class="cover" src="/null"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-04</div><div class="title">Redis主从复制</div></div></a></div><div><a href="/posts/207e4c9d.html" title="Redis学习目录"><img class="cover" src="/null"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-01</div><div class="title">Redis学习目录</div></div></a></div><div><a href="/posts/ed3b1c3a.html" title="Redis常用命令及数据结构相关操作"><img class="cover" src="/null"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-02</div><div class="title">Redis常用命令及数据结构相关操作</div></div></a></div><div><a href="/posts/119ed1dc.html" title="Redis持久化"><img class="cover" src="/null"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-04</div><div class="title">Redis持久化</div></div></a></div><div><a href="/posts/35743b4b.html" title="Redis缓存雪崩、缓存穿透、缓存击穿"><img class="cover" src="/null"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-03</div><div class="title">Redis缓存雪崩、缓存穿透、缓存击穿</div></div></a></div><div><a href="/posts/3a0d04cf.html" title="Redis跳跃表"><img class="cover" src="/null"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-02</div><div class="title">Redis跳跃表</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2022 By D丶Cheng</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/search/local-search.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script></div></body></html>