<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>RabbitMQ | D丶Cheng的博客</title><meta name="description" content="MQ简介什么是MQ?​        MQ通过典型的 生产者和消费者模型，生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，轻松的实现系统间解耦。 为什么要用MQ?​        我们在使用MQ时主要就是为了异步、解耦和削峰。 解耦​        可以在多个系统之间进行解耦，将原本通过网络之间的调用的方"><meta name="keywords" content="消息队列"><meta name="author" content="D丶Cheng"><meta name="copyright" content="D丶Cheng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://chave-z.github.io/posts/b543ced0.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="RabbitMQ"><meta property="og:url" content="https://chave-z.github.io/posts/b543ced0.html"><meta property="og:site_name" content="D丶Cheng的博客"><meta property="og:description" content="MQ简介什么是MQ?​        MQ通过典型的 生产者和消费者模型，生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，轻松的实现系统间解耦。 为什么要用MQ?​        我们在使用MQ时主要就是为了异步、解耦和削峰。 解耦​        可以在多个系统之间进行解耦，将原本通过网络之间的调用的方"><meta property="og:image" content="https://chave-z.github.io/null"><meta property="article:published_time" content="2020-11-01T04:01:00.000Z"><meta property="article:modified_time" content="2021-12-15T06:19:45.371Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '天',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: {"limitCount":50,"languages":{"author":"作者: D丶Cheng","link":"链接: ","source":"来源: D丶Cheng的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2021-12-15 14:19:45'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.1.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/null" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Chave-Z/picture@master/data/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">88</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">16</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">16</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 所有文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MQ%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">MQ简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFMQ"><span class="toc-number">1.1.</span> <span class="toc-text">什么是MQ?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8MQ"><span class="toc-number">1.2.</span> <span class="toc-text">为什么要用MQ?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E8%80%A6"><span class="toc-number">1.2.1.</span> <span class="toc-text">解耦</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5"><span class="toc-number">1.2.2.</span> <span class="toc-text">异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8A%E5%B3%B0"><span class="toc-number">1.2.3.</span> <span class="toc-text">削峰</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%B8%A6%E6%9D%A5%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.</span> <span class="toc-text">使用消息队列带来的一些问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E6%B5%81MQ%E5%AF%B9%E6%AF%94"><span class="toc-number">1.4.</span> <span class="toc-text">主流MQ对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RabbitMQ"><span class="toc-number">2.</span> <span class="toc-text">RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AMQP%E5%92%8CJMS"><span class="toc-number">2.2.</span> <span class="toc-text">AMQP和JMS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JMS"><span class="toc-number">2.2.1.</span> <span class="toc-text">JMS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JMS%E7%AE%80%E4%BB%8B"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">JMS简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JMS%E4%B8%A4%E7%A7%8D%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">JMS两种消息模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JMS-%E4%BA%94%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E6%B6%88%E6%81%AF%E6%AD%A3%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">JMS 五种不同的消息正文格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AMQP"><span class="toc-number">2.2.2.</span> <span class="toc-text">AMQP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JMS%E5%92%8CAMQP%E5%AF%B9%E6%AF%94"><span class="toc-number">2.2.3.</span> <span class="toc-text">JMS和AMQP对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ%E5%AE%89%E8%A3%85"><span class="toc-number">2.3.</span> <span class="toc-text">RabbitMQ安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker%E5%AE%89%E8%A3%85"><span class="toc-number">2.3.1.</span> <span class="toc-text">docker安装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.4.</span> <span class="toc-text">RabbitMQ常见命令行介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%90%AF-%E5%85%B3%E9%97%AD-RabbitMQ"><span class="toc-number">2.4.1.</span> <span class="toc-text">开启&#x2F;关闭 RabbitMQ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B-RabbitMQ-%E7%8A%B6%E6%80%81"><span class="toc-number">2.4.2.</span> <span class="toc-text">查看 RabbitMQ 状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="toc-number">2.4.3.</span> <span class="toc-text">用户相关操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90"><span class="toc-number">2.4.4.</span> <span class="toc-text">权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEtag"><span class="toc-number">2.4.5.</span> <span class="toc-text">设置tag</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E6%93%8D%E4%BD%9C"><span class="toc-number">2.4.6.</span> <span class="toc-text">虚拟主机操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E5%BC%80%E5%90%AFRabbitMQ-%E7%9A%84%E5%9F%BA%E7%A1%80%E4%B8%8A%E5%BC%80%E5%90%AF-web-%E6%8F%92%E4%BB%B6"><span class="toc-number">2.5.</span> <span class="toc-text">在开启RabbitMQ 的基础上开启 web 插件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RabbitMQ-web%E5%90%8E%E5%8F%B0"><span class="toc-number">3.</span> <span class="toc-text">RabbitMQ web后台</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%93%8D%E4%BD%9CRabbitMQ"><span class="toc-number">3.1.</span> <span class="toc-text">Java操作RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hello-World-%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.1.1.</span> <span class="toc-text">Hello World 模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Work-Queues-%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.1.2.</span> <span class="toc-text">Work Queues 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E5%9D%87%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">平均消费模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%BD%E8%80%85%E5%A4%9A%E5%8A%B3"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">能者多劳</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Publish-Subscribe%E5%B9%BF%E6%92%AD%E6%A8%A1%E5%9E%8B%EF%BC%88fanout%EF%BC%88%E6%89%87%E5%87%BA%E6%A8%A1%E5%9E%8B%EF%BC%89%EF%BC%89"><span class="toc-number">3.1.3.</span> <span class="toc-text">Publish&#x2F;Subscribe广播模型（fanout（扇出模型））</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Routing-%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.1.4.</span> <span class="toc-text">Routing 模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Topics-%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.1.5.</span> <span class="toc-text">Topics 模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RPC-%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.1.6.</span> <span class="toc-text">RPC 模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Publisher-Confirms-%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.1.7.</span> <span class="toc-text">Publisher Confirms 模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Boot%E6%95%B4%E5%90%88RabbitMQ"><span class="toc-number">3.2.</span> <span class="toc-text">Spring Boot整合RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitTemplate%E4%BD%BF%E7%94%A8"><span class="toc-number">3.2.1.</span> <span class="toc-text">RabbitTemplate使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Hello-World%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">Hello World模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Work-Queues-%E6%A8%A1%E5%9E%8B-1"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">Work Queues 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B3%E5%9D%87%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%BC%8F-1"><span class="toc-number">3.2.1.2.1.</span> <span class="toc-text">平均消费模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%83%BD%E8%80%85%E5%A4%9A%E5%8A%B3-1"><span class="toc-number">3.2.1.2.2.</span> <span class="toc-text">能者多劳</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fanout-%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.1.3.</span> <span class="toc-text">Fanout 模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Routing-%E6%A8%A1%E5%9E%8B-1"><span class="toc-number">3.2.1.4.</span> <span class="toc-text">Routing 模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Topics-%E6%A8%A1%E5%9E%8B-1"><span class="toc-number">3.2.1.5.</span> <span class="toc-text">Topics 模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RPC-%E6%A8%A1%E5%9E%8B-1"><span class="toc-number">3.2.1.6.</span> <span class="toc-text">RPC 模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Publisher-Confirms-%E6%A8%A1%E5%9E%8B-1"><span class="toc-number">3.2.1.7.</span> <span class="toc-text">Publisher Confirms 模型</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">消息队列中，如何保证消息的顺序性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E8%A2%AB%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9"><span class="toc-number">4.2.</span> <span class="toc-text">RabbitMQ如何保证消息不被重复消费</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rabbitmq%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%E6%B6%88%E6%81%AF%E5%B9%82%E7%AD%89%E6%80%A7%E5%A4%84%E7%90%86"><span class="toc-number">4.3.</span> <span class="toc-text">rabbitmq系列（三）消息幂等性处理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></ol></div></div></div><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">D丶Cheng的博客</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 所有文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">RabbitMQ</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-11-01T04:01:00.000Z" title="发表于 2020-11-01 12:01:00">2020-11-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-15T06:19:45.371Z" title="更新于 2021-12-15 14:19:45">2021-12-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>36分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="MQ简介"><a href="#MQ简介" class="headerlink" title="MQ简介"></a>MQ简介</h1><h2 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ?"></a>什么是MQ?</h2><p>​        MQ通过典型的 <code>生产者</code>和<code>消费者</code>模型，生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，轻松的实现系统间解耦。</p>
<h2 id="为什么要用MQ"><a href="#为什么要用MQ" class="headerlink" title="为什么要用MQ?"></a>为什么要用MQ?</h2><p>​        我们在使用MQ时主要就是为了<strong>异步、解耦和削峰</strong>。</p>
<h3 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h3><p>​        可以在多个系统之间进行解耦，将原本通过网络之间的调用的方式改为使用MQ进行消息的异步通讯，只要该操作不是需要同步的，就可以改为使用MQ进行不同系统之间的联系，这样项目之间不会存在耦合，系统之间不会产生太大的影响，就算一个系统挂了，也只是消息挤压在MQ里面没人进行消费而已，不会对其他的系统产生影响。</p>
<p>不使用MQ的情况：</p>
<img src="https://cdn.jsdelivr.net/gh/Chave-Z/picture@master/data/8494967-8a6c27beefa1978e.png" alt="img" style="zoom:75%;" />

<p>使用MQ进行解耦之后：</p>
<img src="https://cdn.jsdelivr.net/gh/Chave-Z/picture@master/data/8494967-73713abdc4ccf927-20210226091712319.png" alt="img" style="zoom:75%;" />

<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>​        加入一个操作设计到好几个步骤，这些步骤之间不需要同步完成，比如客户去创建了一个订单，还要去客户轨迹系统添加一条轨迹、去库存系统更新库存、去客户系统修改客户的状态等等。这样如果这个系统都直接进行调用，那么将会产生大量的时间，这样对于客户是无法接收的；并且像添加客户轨迹这种操作是不需要去同步操作的，如果使用MQ将客户创建订单时，将后面的轨迹、库存、状态等信息的更新全都放到MQ里面然后去异步操作，这样就可加快系统的访问速度，提供更好的客户体验。</p>
<p>不使用MQ时：</p>
<img src="https://cdn.jsdelivr.net/gh/Chave-Z/picture@master/data/8494967-248455c8863c542e.png" alt="img" style="zoom: 75%;" />

<p>使用MQ进行异步：</p>
<img src="https://cdn.jsdelivr.net/gh/Chave-Z/picture@master/data/8494967-9840c1edd9d24125-20210225150915098.png" alt="img" style="zoom:75%;" />



<h3 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h3><p>​        一个系统访问流量有高峰时期，也有低峰时期，比如说，中午整点有一个抢购活动等等。比如系统平时流量并不高，一秒钟只有100多个并发请求，系统处理没有任何压力，一切风平浪静，到了某个抢购活动时间，系统并发访问了剧增，比如达到了每秒5000个并发请求，而我们的系统每秒只能处理2000个请求，那么由于流量太大，我们的系统、数据库可能就会崩溃。这时如果使用MQ进行流量削峰，将用户的大量消息直接放到MQ里面，然后我们的系统去按自己的最大消费能力去消费这些消息，就可以保证系统的稳定，只是可能要跟进业务逻辑，给用户返回特定页面或者稍后通过其他方式通知其结果。</p>
<img src="https://cdn.jsdelivr.net/gh/Chave-Z/picture@master/data/8494967-5e386c784e984ab3.png" alt="使用MQ进行削峰.png" style="zoom:50%;" />

<h2 id="使用消息队列带来的一些问题"><a href="#使用消息队列带来的一些问题" class="headerlink" title="使用消息队列带来的一些问题"></a>使用消息队列带来的一些问题</h2><ul>
<li><strong>系统复杂性提高：</strong> 加入MQ之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li>
<li><strong>一致性问题：</strong> 消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息就会导致数据不一致的情况了。</li>
</ul>
<h2 id="主流MQ对比"><a href="#主流MQ对比" class="headerlink" title="主流MQ对比"></a>主流MQ对比</h2><table>
<thead>
<tr>
<th>对比方向</th>
<th>概要</th>
</tr>
</thead>
<tbody><tr>
<td>吞吐量</td>
<td>万级的 ActiveMQ 和 RabbitMQ 的吞吐量（ActiveMQ 的性能最差）要比 十万级甚至是百万级的 RocketMQ 和 Kafka 低一个数量级。</td>
</tr>
<tr>
<td>可用性</td>
<td>都可以实现高可用。ActiveMQ 和 RabbitMQ 都是基于主从架构实现高可用性。RocketMQ 基于分布式架构。 kafka 也是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td>时效性</td>
<td>RabbitMQ 基于erlang开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。其他三个都是 ms 级。</td>
</tr>
<tr>
<td>功能支持</td>
<td>除了 Kafka，其他三个功能都较为完备。 Kafka 功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准</td>
</tr>
<tr>
<td>消息丢失</td>
<td>ActiveMQ 和 RabbitMQ 丢失的可能性非常低， RocketMQ 和 Kafka 理论上不会丢失。</td>
</tr>
</tbody></table>
<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>​        RabbitMQ 是采用 Erlang 语言实现 AMQP(Advanced Message Queuing Protocol，高级消息队列协议）的消息中间件，它最初起源于金融系统，用于在分布式系统中存储转发消息。</p>
<p>​        RabbitMQ被越来越多的人认可，这和它在易用性、扩展性、可靠性和高可用性等方面的卓著表现是分不开的。RabbitMQ 的具体特点可以概括为以下几点：</p>
<ul>
<li><strong>可靠性：</strong> RabbitMQ使用一些机制来保证消息的可靠性，如持久化、传输确认及发布确认等。</li>
<li><strong>灵活的路由：</strong> 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能，RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起，也可以通过插件机制来实现自己的交换器。这个后面会在我们将 RabbitMQ 核心概念的时候详细介绍到。</li>
<li><strong>扩展性：</strong> 多个RabbitMQ节点可以组成一个集群，也可以根据实际业务情况动态地扩展集群中节点。</li>
<li><strong>高可用性：</strong> 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队列仍然可用。</li>
<li><strong>支持多种协议：</strong> RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP、MQTT 等多种消息中间件协议。</li>
<li><strong>多语言客户端：</strong> RabbitMQ几乎支持所有常用语言，比如 Java、Python、Ruby、PHP、C#、JavaScript等。</li>
<li><strong>易用的管理界面：</strong> RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息、集群中的节点等。在安装 RabbitMQ 的时候会介绍到，安装好 RabbitMQ 就自带管理界面。</li>
<li><strong>插件机制：</strong> RabbitMQ 提供了许多插件，以实现从多方面进行扩展，当然也可以编写自己的插件。感觉这个有点类似 Dubbo 的 SPI机制。</li>
</ul>
<h2 id="AMQP和JMS"><a href="#AMQP和JMS" class="headerlink" title="AMQP和JMS"></a>AMQP和JMS</h2><h3 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h3><h4 id="JMS简介"><a href="#JMS简介" class="headerlink" title="JMS简介"></a>JMS简介</h4><p>​        JMS（JAVA Message Service,java消息服务）是java的消息服务，JMS的客户端之间可以通过JMS服务进行异步的消息传输。<strong>JMS（JAVA Message Service，Java消息服务）API是一个消息服务的标准或者说是规范</strong>，允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。<strong>ActiveMQ 就是基于 JMS 规范实现的。</strong></p>
<h4 id="JMS两种消息模型"><a href="#JMS两种消息模型" class="headerlink" title="JMS两种消息模型"></a>JMS两种消息模型</h4><p><strong>①点到点（P2P）模型</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Chave-Z/picture@master/data/162e7185572ca37d.gif" alt="点到点（P2P）模型"> 　</p>
<p>​        使用<strong>队列（Queue）</strong>作为消息通信载体；满足<strong>生产者与消费者模式</strong>，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。比如：我们生产者发送100条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）</p>
<p><strong>② 发布/订阅（Pub/Sub）模型</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Chave-Z/picture@master/data/162e7187c268eaa5.gif" alt="发布/订阅（Pub/Sub）模型"> 　</p>
<p>​        发布订阅模型（Pub/Sub） 使用<strong>主题（Topic）</strong>作为消息通信载体，类似于<strong>广播模式</strong>；发布者发布一条消息，该消息通过主题传递给所有的订阅者，<strong>在一条消息广播之后才订阅的用户则是收不到该条消息的</strong>。</p>
<h4 id="JMS-五种不同的消息正文格式"><a href="#JMS-五种不同的消息正文格式" class="headerlink" title="JMS 五种不同的消息正文格式"></a>JMS 五种不同的消息正文格式</h4><p>​        JMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。</p>
<ul>
<li>StreamMessage —— Java原始值的数据流</li>
<li>MapMessage——一套名称-值对</li>
<li>TextMessage——一个字符串对象</li>
<li>ObjectMessage——一个序列化的 Java对象</li>
<li>BytesMessage——一个字节的数据流</li>
</ul>
<h3 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h3><p>​        AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准 <strong>高级消息队列协议</strong>（二进制应用层协议），是应用层协议的一个开放标准,为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。<strong>RabbitMQ 就是基于 AMQP 协议实现的。</strong></p>
<h3 id="JMS和AMQP对比"><a href="#JMS和AMQP对比" class="headerlink" title="JMS和AMQP对比"></a>JMS和AMQP对比</h3><table>
<thead>
<tr>
<th>对比方向</th>
<th>JMS</th>
<th>AMQP</th>
</tr>
</thead>
<tbody><tr>
<td>定义</td>
<td>Java API</td>
<td>协议</td>
</tr>
<tr>
<td>跨语言</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>跨平台</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>支持消息类型</td>
<td>提供两种消息模型：①Peer-2-Peer;②Pub/sub</td>
<td>提供了五种消息模型：①direct exchange；②fanout exchange；③topic change；④headers exchange；⑤system exchange。本质来讲，后四种和JMS的pub/sub模型没有太大差别，仅是在路由机制上做了更详细的划分；</td>
</tr>
<tr>
<td>支持消息类型</td>
<td>支持多种消息类型 ，我们在上面提到过</td>
<td>byte[]（二进制）</td>
</tr>
</tbody></table>
<p><strong>总结：</strong></p>
<ul>
<li>AMQP 为消息定义了线路层（wire-level protocol）的协议，而JMS所定义的是API规范。在 Java 体系中，多个client均可以通过JMS进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而AMQP天然具有跨平台、跨语言特性。</li>
<li>JMS 支持TextMessage、MapMessage 等复杂的消息类型；而 AMQP 仅支持 byte[] 消息类型（复杂的类型可序列化后发送）。</li>
<li>由于Exchange 提供的路由算法，AMQP可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 队列 和 主题/订阅 方式两种。</li>
</ul>
<h2 id="RabbitMQ安装"><a href="#RabbitMQ安装" class="headerlink" title="RabbitMQ安装"></a>RabbitMQ安装</h2><h3 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h3><p><strong>安装</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:3.8.12-management</span><br></pre></td></tr></table></figure>

<p><strong>运行镜像</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name rabbit -p 5672:5672 -p 15672:15672 rabbitmq:3.8.12-management</span><br></pre></td></tr></table></figure>

<p>5672：应用访问端口；15672：控制台Web端口号 。浏览器访问的管理后台地址为：<a target="_blank" rel="noopener" href="http://host-ip:15672/">http://host-ip:15672</a> ，默认用户名密码为 guest/guest</p>
<h2 id="RabbitMQ常见命令行介绍"><a href="#RabbitMQ常见命令行介绍" class="headerlink" title="RabbitMQ常见命令行介绍"></a>RabbitMQ常见命令行介绍</h2><h3 id="开启-关闭-RabbitMQ"><a href="#开启-关闭-RabbitMQ" class="headerlink" title="开启/关闭 RabbitMQ"></a>开启/关闭 RabbitMQ</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-server -detached # 开启</span><br><span class="line">rabbitmq-server stop		# 关闭</span><br></pre></td></tr></table></figure>

<h3 id="查看-RabbitMQ-状态"><a href="#查看-RabbitMQ-状态" class="headerlink" title="查看 RabbitMQ 状态"></a>查看 RabbitMQ 状态</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl status</span><br></pre></td></tr></table></figure>

<h3 id="用户相关操作"><a href="#用户相关操作" class="headerlink" title="用户相关操作"></a>用户相关操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加用户</span></span><br><span class="line">rabbitmqctl add_user 账户名 密码</span><br><span class="line">eg: rabbitmqctl add_user guest2 guest2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除用户</span></span><br><span class="line">rabbitmqctl delete_user root</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改密码</span></span><br><span class="line">rabbitmqctl change_password 用户名 新密码</span><br><span class="line"><span class="meta">#</span><span class="bash">查看所有用户</span></span><br><span class="line">rabbitmqctl list_users</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除用户</span></span><br><span class="line">rabbitmqctl delete_user 用户名</span><br></pre></td></tr></table></figure>

<h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置用户权限</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> rabbitmqctl set_permissions -p &lt;虚拟机&gt; &lt;用户名&gt; <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span></span></span><br><span class="line">rabbitmqctl set_permissions -p &quot;/&quot; 用户名 &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看用户权限</span></span><br><span class="line">rabbitmqctl list_user_permissions 用户名</span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如 rabbitmqctl list_user_permissions guest结果如下：</span></span><br><span class="line">Listing permissions for user &quot;guest&quot; ...</span><br><span class="line">vhost	configure	write	read</span><br><span class="line">/	.*	.*	.*</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除用户权限</span></span><br><span class="line">rabbitmqctl clear_permissions -p &lt;虚拟机&gt; &lt;用户名&gt;</span><br></pre></td></tr></table></figure>

<h3 id="设置tag"><a href="#设置tag" class="headerlink" title="设置tag"></a>设置tag</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_user_tags 用户名 administrator</span><br></pre></td></tr></table></figure>

<h3 id="虚拟主机操作"><a href="#虚拟主机操作" class="headerlink" title="虚拟主机操作"></a>虚拟主机操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 增加一个虚拟主机 </span></span><br><span class="line">rabbitmqctl add_vhost /cloudmall</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有的虚拟主机</span></span><br><span class="line">rabbitmqctl list_vhosts;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看虚拟主机的权限</span></span><br><span class="line">rabbitmqctl list_permissions -p /cloudmall</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除虚拟主机</span></span><br><span class="line">rabbitmqctl delete_vhost /cloudmall </span><br></pre></td></tr></table></figure>

<h2 id="在开启RabbitMQ-的基础上开启-web-插件"><a href="#在开启RabbitMQ-的基础上开启-web-插件" class="headerlink" title="在开启RabbitMQ 的基础上开启 web 插件"></a>在开启RabbitMQ 的基础上开启 web 插件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>

<h1 id="RabbitMQ-web后台"><a href="#RabbitMQ-web后台" class="headerlink" title="RabbitMQ web后台"></a>RabbitMQ web后台</h1><p>​        web后台就比较人性化了，我们通过<a href="http://host-ip:15672访问，并且登录上以后会看到如下界面：">http://host-ip:15672访问，并且登录上以后会看到如下界面：</a></p>
<img src="https://cdn.jsdelivr.net/gh/Chave-Z/picture@master/data/007S8ZIlgy1gixzuyzbl6j31k40u0wob.jpg" alt="image-20200921090257107" style="zoom:67%;" />

<h2 id="Java操作RabbitMQ"><a href="#Java操作RabbitMQ" class="headerlink" title="Java操作RabbitMQ"></a>Java操作RabbitMQ</h2><p>​        访问<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/getstarted.html">RabbitMQ官网</a>会发现首页有七种模式，且每一种模式都有，下面我们来逐个使用一下，其中RabbitMQUtils代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建连接工厂</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//2. 配置连接工厂</span></span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="comment">//3. 获取连接对象</span></span><br><span class="line">        <span class="keyword">return</span> connectionFactory.newConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeChannelAndConnection</span><span class="params">(Channel channel, Connection connection)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//5. 关闭通道</span></span><br><span class="line">        channel.close();</span><br><span class="line">        <span class="comment">//6. 关闭连接</span></span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Hello-World-模型"><a href="#Hello-World-模型" class="headerlink" title="Hello World 模型"></a>Hello World 模型</h3><p><img src="https://cdn.jsdelivr.net/gh/Chave-Z/picture@master/data/python-one.png" alt="img"></p>
<p>在上图的模型中，有以下概念：</p>
<ul>
<li>P：生产者，也就是要发送消息的程序</li>
<li>C：消费者：消息的接受者，会一直等待消息到来。</li>
<li>queue：图中红色部分就是消息队列，类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。</li>
</ul>
<p>首先我们定义一个生产者，写入如下的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 获取连接对象</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="comment">//2. 创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 3. 申明队列</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 参数1（queue）：队列名，没有的话会自动创建</span></span><br><span class="line"><span class="comment">         * 参数2（durable）：是否持久化，在 RabbitMQ 重启时是否会自动删除该队列（即使保存队列，队列中的消息还是会被清空）</span></span><br><span class="line"><span class="comment">         * 参数3（exclusive）：是否独占队列</span></span><br><span class="line"><span class="comment">         * 参数4（autoDelete）：当队列中没有消息时是否自动删除</span></span><br><span class="line"><span class="comment">         * 参数5（arguments）：队列的其他属性，这里可以填构造方法中的一些参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;hello&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 4. 发布信息</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 参数1（exchange）：交换机，直连模式不需要交换机</span></span><br><span class="line"><span class="comment">         * 参数2（routingKey）：路由key，直连模式就是对列名称</span></span><br><span class="line"><span class="comment">         * 参数3（props）：其他属性</span></span><br><span class="line"><span class="comment">         * 参数4（body）：要发布的信息，需要转为字节码</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;hello rabbitmq&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">// 关闭</span></span><br><span class="line">        RabbitMQUtils.closeChannelAndConnection(channel, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行两次以后，这里会出现对应的消息条数：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Chave-Z/picture@master/data/image-20210225165628141.png" alt="image-20210225165628141"></p>
<p>定义一个消费者：</p>
<p>代码就基本一样了，只是把第四步的basicPublish方法改为了basicConsume方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 获取连接对象</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 3. 申明队列 =&gt; 这里需要跟发布者一一对应</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 参数1（queue）：队列名，没有的话会自动创建</span></span><br><span class="line"><span class="comment">         * 参数2（durable）：是否持久化，在 RabbitMQ 重启时是否会自动删除该队列（即使保存队列，队列中的消息还是会被清空）</span></span><br><span class="line"><span class="comment">         * 参数3（exclusive）：是否独占队列</span></span><br><span class="line"><span class="comment">         * 参数4（autoDelete）：当队列中没有消息时是否自动删除</span></span><br><span class="line"><span class="comment">         * 参数5（arguments）：队列的其他属性，这里可以填构造方法中的一些参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;hello&quot;</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 4. 获取消息</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 参数1（queue）：队列名</span></span><br><span class="line"><span class="comment">         * 参数2（autoAck）：如果服务器应考虑消息传递后已确认，则为true</span></span><br><span class="line"><span class="comment">         * 参数3（callback）：一个实现了 Consumer 接口的对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;hello&quot;</span>,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 5. 处理信息的接收</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> consumerTag  消费者标签</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> envelope     消息的打包数据</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> properties   AMQP的属性，消息的内容头信息</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> body         信息的内容</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//输出消息</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里不关闭的话会一直监听，一但有消息进入，就会输出。</span></span><br><span class="line">        <span class="comment">// RabbitMQUtils.closeChannelAndConnection(channel, connection);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行以后就会，只要生产者推送了消息，消费者这边就会打印。</p>
<h3 id="Work-Queues-模型"><a href="#Work-Queues-模型" class="headerlink" title="Work Queues 模型"></a>Work Queues 模型</h3><p><img src="https://cdn.jsdelivr.net/gh/Chave-Z/picture@master/data/python-two.png" alt="img"></p>
<p>​        <code>Work queues</code>，也被称为（<code>Task queues</code>），<strong>任务模型</strong>。当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用work 模型：<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。队列中的消息一旦消费，就会消失，因此任务是不会被重复执行的。</p>
<h4 id="平均消费模式"><a href="#平均消费模式" class="headerlink" title="平均消费模式"></a>平均消费模式</h4><ul>
<li>生产者</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 通过自行封装的方法获取连接对象</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="comment">//2. 获取通道对象</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//3. 申明队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;work&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//4. 发布信息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,<span class="string">&quot;work&quot;</span>,<span class="keyword">null</span>,(<span class="string">&quot;发布消息&quot;</span>+i).getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5. 通过自行封装的方法关闭资源</span></span><br><span class="line">        RabbitMQUtils.closeChannelAndConnection(channel,connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>消费者（代码拷贝几份就行）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerCustomer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 通过自行封装的方法获取连接对象</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="comment">//2. 获取通道对象</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//3. 申明队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;work&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//4. 消费消息</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;work&quot;</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;这是消费者1在消费信息：&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后发现如下结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Chave-Z/picture@master/data/image-20210225172134307.png" alt="image-20210225172134307"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Chave-Z/picture@master/data/image-20210225172149906.png" alt="image-20210225172149906"></p>
<p>​        从结果中可以发现 work 模型在默认情况下，RabbitMQ 会按顺序将每个消息发送给下一个消费者者。平均而言，每个消费者都会收到相同数量的消息。这种分发消息的方式称为轮询。</p>
<h4 id="能者多劳"><a href="#能者多劳" class="headerlink" title="能者多劳"></a>能者多劳</h4><p>​        在平均消费模式中，消费者只要从队列中拿到消息，就立刻发送确认机制，但是他也会出现如下的问题：</p>
<ol>
<li><p>在处理消息的时候就突然宕机了或者出现意外了，这样消息还没来得及消费就遗失了，就造成业务数据的失。</p>
</li>
<li><p><strong>两个消费者处理消息的效率不一样</strong>，就有可能造成一个消费者已经消费完消息然后闲着，而另外一个消费者拿到了消息，却一直处于处理消息的状态，造成资源的浪费。</p>
</li>
</ol>
<p>要实现这个模式，我们需要对消费者进行改造：</p>
<ul>
<li>关闭消息自动确认机制</li>
<li>不一次性把消息交给消费者</li>
<li>主动进行确认</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Chave-Z/picture@master/data/image-20210225173949169.png" alt="image-20210225173949169"></p>
<p>再次测试：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Chave-Z/picture@master/data/image-20210225174024151.png" alt="image-20210225174024151"></p>
<img src="https://cdn.jsdelivr.net/gh/Chave-Z/picture@master/data/image-20210225174040070.png" alt="image-20210225174040070" style="zoom:150%;" />

<p>​        从上述结果中可以发现，由于处理能力的不同，所以消费者1就只来得及接收并处理很少信息，其他信息都被消费者2接收并处理了，这样就达到了“能者多劳”的效果了。</p>
<h3 id="Publish-Subscribe广播模型（fanout（扇出模型））"><a href="#Publish-Subscribe广播模型（fanout（扇出模型））" class="headerlink" title="Publish/Subscribe广播模型（fanout（扇出模型））"></a>Publish/Subscribe广播模型（fanout（扇出模型））</h3><p><img src="https://cdn.jsdelivr.net/gh/Chave-Z/picture@master/data/python-three-overall.png" alt="img"></p>
<p>​        在工作队列模式中，我们的设想是每一条消息只会被转发给一个消费者，而Publish/Subscribe模型是一种广播模型，也就是一个生产者可以发一个消息，进行广播，让多个消费者消费同一个消息。</p>
<p>在广播模式下，消息发送流程是这样的：</p>
<ul>
<li>可以有多个消费者</li>
<li>每个<strong>消费者有自己的queue</strong>（队列）</li>
<li>每个<strong>队列都要绑定到Exchange</strong>（交换机）</li>
<li><strong>生产者发送的消息，只能发送到交换机</strong>，并且<strong>交换机来决定要发给哪个队列，生产者无法决定</strong>。</li>
<li>交换机把消息发送给绑定过的所有队列</li>
<li>队列的消费者都能拿到消息。实现一条消息被多个消费者消费</li>
</ul>
<p><strong>生产者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 通过自行封装的方法获取连接对象</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="comment">//2. 获取通道对象</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//3. 声明交换机 =&gt; fanout 模式的交换机 type 需要制定为 fanout</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;logs&quot;</span>,<span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">//4. 广播消息</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;logs&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="keyword">null</span>,<span class="string">&quot;这是一条测试广播....&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">//5. 通过自行封装的方法关闭资源</span></span><br><span class="line">        RabbitMQUtils.closeChannelAndConnection(channel,connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>新建几个消费者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 通过自行封装的方法获取连接对象</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="comment">//2. 获取通道对象</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//3. 绑定交换机 =&gt; fanout 模式的交换机 type 需要制定为 fanout</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;logs&quot;</span>,<span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">//4. 创建临时队列，这里会随机生成一个队列名称</span></span><br><span class="line">        String queue = channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//5. 将临时队列绑定到交换机上，fanout模式暂时还不需要routingKey</span></span><br><span class="line">        channel.queueBind(queue,<span class="string">&quot;logs&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//6. 消费消息</span></span><br><span class="line">        channel.basicConsume(queue,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者1接收到消息：&quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行消费者，然后再运行生产者，就会发现每一个消费者都能接收到消息了。</p>
<h3 id="Routing-模型"><a href="#Routing-模型" class="headerlink" title="Routing 模型"></a>Routing 模型</h3><p>​        在广播/扇出模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到 Direct 类型的Exchange。</p>
<p>在 Direct 模型下：</p>
<ul>
<li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li>
<li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li>
<li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li>
</ul>
<p><strong>Routing模式的图解如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Chave-Z/picture@master/data/python-four.png" alt="img"></p>
<ul>
<li>P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。</li>
<li>X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列</li>
<li>C1：消费者，其所在队列指定了需要routing key 为 error 的消息</li>
<li>C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息</li>
</ul>
<p><strong>生产者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 通过自行封装的方法获取连接对象</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="comment">//2. 获取通道对象</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//3. 声明交换机 =&gt; routing 模型的交换机类型是 direct</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;ex_direct&quot;</span>,<span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        <span class="comment">//4. 广播消息</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;ex_direct&quot;</span>,<span class="string">&quot;error&quot;</span>,<span class="keyword">null</span>,<span class="string">&quot;这是一条error广播....&quot;</span>.getBytes());</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;ex_direct&quot;</span>,<span class="string">&quot;info&quot;</span>,<span class="keyword">null</span>,<span class="string">&quot;这是一条info广播....&quot;</span>.getBytes());</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;ex_direct&quot;</span>,<span class="string">&quot;warning&quot;</span>,<span class="keyword">null</span>,<span class="string">&quot;这是一条warning广播....&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">//5. 通过自行封装的方法关闭资源</span></span><br><span class="line">        RabbitMQUtils.closeChannelAndConnection(channel,connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者1 (只消费error信息)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 通过自行封装的方法获取连接对象</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="comment">//2. 获取通道对象</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//3. 绑定交换机 =&gt; routing 模型的交换机类型是 direct</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;ex_direct&quot;</span>,<span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        <span class="comment">//4. 创建临时队列</span></span><br><span class="line">        String queue = channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//5. 将临时队列绑定到交换机上 =&gt; 消费者1只能消费 routingKey 为 error 的消息</span></span><br><span class="line">        channel.queueBind(queue,<span class="string">&quot;ex_direct&quot;</span>,<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="comment">//6. 消费消息</span></span><br><span class="line">        channel.basicConsume(queue,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者1接收到消息：&quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者2(消费error、info、warning信息)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 通过自行封装的方法获取连接对象</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="comment">//2. 获取通道对象</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//3. 绑定交换机 =&gt; routing 模型的交换机类型是 direct</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;ex_direct&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        <span class="comment">//4. 创建临时队列</span></span><br><span class="line">        String queue = channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//5. 消费者2可以消费 routingKey 为 info、error 和 warning 的消息</span></span><br><span class="line">        channel.queueBind(queue, <span class="string">&quot;ex_direct&quot;</span>, <span class="string">&quot;info&quot;</span>);</span><br><span class="line">        channel.queueBind(queue, <span class="string">&quot;ex_direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">        channel.queueBind(queue, <span class="string">&quot;ex_direct&quot;</span>, <span class="string">&quot;warning&quot;</span>);</span><br><span class="line">        <span class="comment">//6. 消费消息</span></span><br><span class="line">        channel.basicConsume(queue, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者2接收到消息：&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试结果</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Chave-Z/picture@master/data/image-20210226100714320.png" alt="image-20210226100714320"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Chave-Z/picture@master/data/image-20210226100729738.png" alt="image-20210226100729738"></p>
<h3 id="Topics-模型"><a href="#Topics-模型" class="headerlink" title="Topics 模型"></a>Topics 模型</h3><p><img src="https://cdn.jsdelivr.net/gh/Chave-Z/picture@master/data/python-five.png" alt="img"></p>
<p>​        <code>Topics</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符。这种模型<code>Routingkey</code> 一般都是由一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code></p>
<table>
<thead>
<tr>
<th>通配符名称</th>
<th>功能</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配不多不少恰好1个词</td>
<td>msg.*    只能匹配 msg.log或者msg.info等</td>
</tr>
<tr>
<td>#</td>
<td>匹配一个或多个词</td>
<td>msg.#    匹配msg、msg.log、msg.log.info、msg.log.error.system 等</td>
</tr>
</tbody></table>
<p><strong>生成者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 通过自行封装的方法获取连接对象</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="comment">//2. 获取通道对象</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//3. 声明交换机 =&gt; topics 模型的交换机类型为 topic</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;ex_topic&quot;</span>,<span class="string">&quot;topic&quot;</span>);</span><br><span class="line">        <span class="comment">//4. 广播消息</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;ex_topic&quot;</span>,<span class="string">&quot;msg&quot;</span>,<span class="keyword">null</span>,<span class="string">&quot;这是一条 msg 广播&quot;</span>.getBytes());</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;ex_topic&quot;</span>,<span class="string">&quot;msg.info&quot;</span>,<span class="keyword">null</span>,<span class="string">&quot;这是一条 msg.info 信息&quot;</span>.getBytes());</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;ex_topic&quot;</span>,<span class="string">&quot;msg.info.error&quot;</span>,<span class="keyword">null</span>,<span class="string">&quot;这是一条 msg.info.error 广播&quot;</span>.getBytes());</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;ex_topic&quot;</span>,<span class="string">&quot;msg.info.error.system&quot;</span>,<span class="keyword">null</span>,<span class="string">&quot;这是一条 msg.info.error.system 广播&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">//5. 关闭资源</span></span><br><span class="line">        RabbitMQUtils.closeChannelAndConnection(channel,connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 通过自行封装的方法获取连接对象</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="comment">//2. 获取通道对象</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//3. 绑定交换机 =&gt; topic 模型的交换机类型是 topic</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;ex_topic&quot;</span>,<span class="string">&quot;topic&quot;</span>);</span><br><span class="line">        <span class="comment">//4. 创建临时队列</span></span><br><span class="line">        String queue = channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//5. 将临时队列绑定到交换机上 =&gt; 消费者1只能消费 routingKey 为 msg.* 的消息</span></span><br><span class="line">        <span class="comment">// routingKey 的每个单词之间用&quot;.&quot;来分割，通配符 * 表示只能匹配1个单词，如 msg.info</span></span><br><span class="line">        channel.queueBind(queue,<span class="string">&quot;ex_topic&quot;</span>,<span class="string">&quot;msg.*&quot;</span>);</span><br><span class="line">        <span class="comment">//6. 消费消息</span></span><br><span class="line">        channel.basicConsume(queue,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者1接收到消息：&quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 通过自行封装的方法获取连接对象</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="comment">//2. 获取通道对象</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//3. 绑定交换机 =&gt; topic 模型的交换机类型是 topic</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;ex_topic&quot;</span>, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line">        <span class="comment">//4. 创建临时队列</span></span><br><span class="line">        String queue = channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//5. 将临时队列绑定到交换机上 =&gt; 消费者2只能消费 routingKey 为 msg.# 的消息</span></span><br><span class="line">        <span class="comment">// routingKey 的每个单词之间用&quot;.&quot;来分割，通配符 # 表示只能匹配1个单词或多个，</span></span><br><span class="line">        <span class="comment">// 如 msg、msg.info, msg.info.error、msg.info.error.system</span></span><br><span class="line">        channel.queueBind(queue, <span class="string">&quot;ex_topic&quot;</span>, <span class="string">&quot;msg.#&quot;</span>);</span><br><span class="line">        <span class="comment">//6. 消费消息</span></span><br><span class="line">        channel.basicConsume(queue, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者2接收到消息：&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试结果</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Chave-Z/picture@master/data/image-20210226102414135.png" alt="image-20210226102414135" style="zoom:150%;" />

<p><img src="https://cdn.jsdelivr.net/gh/Chave-Z/picture@master/data/image-20210226102523549.png" alt="image-20210226102523549"></p>
<h3 id="RPC-模型"><a href="#RPC-模型" class="headerlink" title="RPC 模型"></a>RPC 模型</h3><p>​        在 Work Queues 模型中，我们学习了如何使用工作队列在多个工作人员之间分配耗时的任务。但是，如果我们需要在远程计算机上运行功能并等待结果怎么办？那就可以用 RPC 模型（远程过程调用）。</p>
<p>​        我们将使用 RabbitMQ 构建RPC系统：客户端和可伸缩 RPC 服务器。由于我们没有值得分配的耗时任务，因此我们将创建一个虚拟 RPC服务，该服务返回斐波那契数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Chave-Z/picture@master/data/python-six.png" alt="img"></p>
<ul>
<li>对于RPC请求，客户端发送一条消息，该消息具有两个属性：replyTo（设置为仅为该请求创建的匿名互斥队列）和correlationId（设置为每个请求的唯一值）。</li>
<li>该请求被发送到rpc_queue队列。</li>
<li>RPC工作程序（又名：服务器）正在等待该队列上的请求。出现请求时，它会使用 replyTo 字段中的队列来完成工作，并将消息和结果发送回客户端。</li>
<li>客户端等待答复队列中的数据。出现消息时，它将检查correlationId属性。如果它与请求中的值匹配，则将响应返回给应用程序。</li>
</ul>
<p><strong>生产者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Connection connection;</span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="comment">//发送请求的队列名称</span></span><br><span class="line">    <span class="keyword">private</span> String requestQueueName = <span class="string">&quot;rpc_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//初始化 RPCClient</span></span><br><span class="line">        RpcClient rpcClient = <span class="keyword">new</span> RpcClient();</span><br><span class="line">        rpcClient.connection = RabbitMQUtils.getConnection();</span><br><span class="line">        rpcClient.channel = rpcClient.connection.createChannel();</span><br><span class="line">        <span class="comment">//发送 request 请求信息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;现在客户端希望计算 &quot;</span> + i + <span class="string">&quot; * 10&quot;</span>);</span><br><span class="line">            String response = rpcClient.call(Integer.toString(i));</span><br><span class="line">            System.out.println(<span class="string">&quot;计算结果为： &quot;</span> + i + <span class="string">&quot; * 10 = &quot;</span> + response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        close(rpcClient);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送请求，希望调用远程的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个相关ID</span></span><br><span class="line">        <span class="keyword">final</span> String correlationId = UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">//回调队列</span></span><br><span class="line">        String replyQueueName = channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//定义消息属性</span></span><br><span class="line">        AMQP.BasicProperties basicProperties = <span class="keyword">new</span> AMQP.BasicProperties</span><br><span class="line">                .Builder()</span><br><span class="line">                <span class="comment">//设置相关ID</span></span><br><span class="line">                .correlationId(correlationId)</span><br><span class="line">                <span class="comment">//设置回调队列</span></span><br><span class="line">                .replyTo(replyQueueName)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存储相应信息</span></span><br><span class="line">        <span class="keyword">final</span> BlockingQueue&lt;String&gt; response = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, requestQueueName, basicProperties, message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费消息</span></span><br><span class="line">        String ctag = channel.basicConsume(replyQueueName, <span class="keyword">true</span></span><br><span class="line">                <span class="comment">//参数3：服务器端传过来的回调对象</span></span><br><span class="line">                , <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String consumerTag, Delivery message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (message.getProperties().getCorrelationId().equals(correlationId)) &#123;</span><br><span class="line">                            response.offer(<span class="keyword">new</span> String(message.getBody(), StandardCharsets.UTF_8));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String consumerTag)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        String result = response.take();</span><br><span class="line">        channel.basicCancel(ctag);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(RpcClient rpcClient)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        RabbitMQUtils.closeChannelAndConnection(rpcClient.channel, rpcClient.connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RPC_QUEUE_NAME = <span class="string">&quot;rpc_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//调用自行封装的工具类获取连接对象</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="comment">//获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(RPC_QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//清除队列</span></span><br><span class="line">        channel.queuePurge(RPC_QUEUE_NAME);</span><br><span class="line">        <span class="comment">//每次处理一条信息</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//定义一个监听器</span></span><br><span class="line">        Object monitor = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">//定义回调信息</span></span><br><span class="line">        DeliverCallback deliverCallback = <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> consumerTag 消费者标签，可以与消费者建立联系</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> message     消费者发送过来的消息(消息属性、消息封装体、消息没人)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String consumerTag, Delivery message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//定义信息属性</span></span><br><span class="line">                AMQP.BasicProperties basicProperties = <span class="keyword">new</span> AMQP.BasicProperties</span><br><span class="line">                        .Builder()</span><br><span class="line">                        .correlationId(message.getProperties().getCorrelationId()) <span class="comment">//指明关联ID</span></span><br><span class="line">                        .build();</span><br><span class="line">                <span class="comment">//定义相应信息</span></span><br><span class="line">                String response = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="comment">//解析request信息</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String s = <span class="keyword">new</span> String(message.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">                    <span class="keyword">int</span> i = Integer.parseInt(s);</span><br><span class="line">                    System.out.println(<span class="string">&quot;正在计算 &quot;</span> + i + <span class="string">&quot; * &quot;</span> + <span class="number">10</span>);</span><br><span class="line">                    response = String.valueOf(i * <span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//发布 response 消息</span></span><br><span class="line">                    channel.basicPublish(<span class="string">&quot;&quot;</span>, message.getProperties().getReplyTo(), basicProperties, response.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                    <span class="comment">//手动确认信息</span></span><br><span class="line">                    channel.basicAck(message.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">//RabbitMq 消费者工作线程通知 RPC 服务器所有者线程</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (monitor) &#123;</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * notify()</span></span><br><span class="line"><span class="comment">                         *</span></span><br><span class="line"><span class="comment">                         * 唤醒处于等待的线程</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        monitor.notify();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//消费客户端发送过来的请求消息</span></span><br><span class="line">        channel.basicConsume(RPC_QUEUE_NAME, <span class="keyword">false</span>, deliverCallback, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">            <span class="comment">// 等待并准备好使用来自RPC客户端的消息</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String consumerTag)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (monitor) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                             * wait()</span></span><br><span class="line"><span class="comment">                             *</span></span><br><span class="line"><span class="comment">                             * 使得当前线程立刻停止运行，处于等待状态（WAIT），</span></span><br><span class="line"><span class="comment">                             * 并将当前线程置入锁对象的等待队列中，</span></span><br><span class="line"><span class="comment">                             * 直到被通知（notify）或被中断为止。</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            monitor.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>计算结果</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Chave-Z/picture@master/data/image-20210226104700633.png" alt="image-20210226104700633"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Chave-Z/picture@master/data/image-20210226104724495.png" alt="image-20210226104724495"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/820533c7b41e94dd59eb5c6dc7e7e572.png" alt="image-20200923112003146"></p>
<h3 id="Publisher-Confirms-模型"><a href="#Publisher-Confirms-模型" class="headerlink" title="Publisher Confirms 模型"></a>Publisher Confirms 模型</h3><h2 id="Spring-Boot整合RabbitMQ"><a href="#Spring-Boot整合RabbitMQ" class="headerlink" title="Spring Boot整合RabbitMQ"></a>Spring Boot整合RabbitMQ</h2><ul>
<li>创建项目、引入依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在application.yml配置RabbitMQ</li>
</ul>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">rabbitmq-test</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">    <span class="comment">#虚拟host 可以不设置,使用server默认host</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure>

<p>​        基本上这个时候我们使用RabbitTemplate就可以进行相关操作了，但是我们还得了解几个概念，首先我们查看Spring Boot中RabbitMQ的自动配置类RabbitAutoConfiguration：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnSingleCandidate(ConnectionFactory.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(RabbitOperations.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">rabbitTemplate</span><span class="params">(RabbitTemplateConfigurer configurer, ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">    RabbitTemplate template = <span class="keyword">new</span> RabbitTemplate();</span><br><span class="line">    configurer.configure(template, connectionFactory);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnSingleCandidate(ConnectionFactory.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.rabbitmq&quot;, name = &quot;dynamic&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AmqpAdmin <span class="title">amqpAdmin</span><span class="params">(ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RabbitAdmin(connectionFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到其向容器中注入了两个组件：RabbitTemplate和AmqpAdmin，这两个组件的作用如下：</p>
<p><strong>RabbitTemplate</strong>：可以发送消息、接收消息。</p>
<p><strong>AmqpAdmin</strong>：负责操作Exchange、Queue、Binding等，比如创建、删除、解绑。</p>
<h3 id="RabbitTemplate使用"><a href="#RabbitTemplate使用" class="headerlink" title="RabbitTemplate使用"></a>RabbitTemplate使用</h3><p>我们先来看一下RabbitTemplate，它主要有两个方法：</p>
<p>**1. send(String exchange, String routingKey, Message message)**：需要自己定义一个Message,比较麻烦。</p>
<p>**2. convertAndSend(String exchange, String routingKey, Object object)**：只需要传入一个Object,自动序列化发送给rabbitmq，object默认被当成消息体。</p>
<h4 id="Hello-World模式"><a href="#Hello-World模式" class="headerlink" title="Hello World模式"></a>Hello World模式</h4><ul>
<li>生产者</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RabbitmqHelloWordTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Hello World 模型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数1：队列名称</span></span><br><span class="line"><span class="comment">         * 参数2：消息内容</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 注意：当没有消费者在监听的时候，生产者的运行是不会有任何效果的。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="comment">// 发送字符串</span></span><br><span class="line">        <span class="comment">// rabbitTemplate.convertAndSend(&quot;hello&quot;,&quot;hello world&quot;);</span></span><br><span class="line">        <span class="comment">// 也可以发送map</span></span><br><span class="line">        HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;hello&quot;</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>消费者</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">// 注明消费者在监听 hello 这个队列</span></span><br><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(value = &quot;hello&quot;,durable = &quot;false&quot;,autoDelete = &quot;true&quot;))</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RabbitHandler 注解指明这是接收到消息时的回调方法</span></span><br><span class="line"><span class="comment">     * message 参数是传过来的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="comment">// 字符串类型用这个接收 </span></span><br><span class="line">    <span class="comment">// public void receive(String message)&#123;</span></span><br><span class="line">    <span class="comment">// 接收map</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Map message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;message = &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Work-Queues-模型-1"><a href="#Work-Queues-模型-1" class="headerlink" title="Work Queues 模型"></a>Work Queues 模型</h4><h5 id="平均消费模式-1"><a href="#平均消费模式-1" class="headerlink" title="平均消费模式"></a>平均消费模式</h5><ul>
<li><strong>生产者</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkQueuesTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Work Queues 模型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWorkQueues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            rabbitTemplate.convertAndSend(<span class="string">&quot;work-queues&quot;</span>,<span class="string">&quot;消息&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>消费者</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果直接在方法上加  <span class="doctag">@RabbitListener</span> 注解的话，那就不需要加 <span class="doctag">@RabbitHandler</span> 注解了，默认就加上了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queuesToDeclare = @Queue(value = &quot;work-queues&quot;))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive1</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是 work 模型的消息者1得到的 message = &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queuesToDeclare = @Queue(value = &quot;work-queues&quot;))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive2</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是 work 模型的消息者2得到的 message = &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试结果为：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这是 work 模型的消息者2得到的 message &#x3D; 消息0</span><br><span class="line">这是 work 模型的消息者1得到的 message &#x3D; 消息1</span><br><span class="line">这是 work 模型的消息者2得到的 message &#x3D; 消息2</span><br><span class="line">这是 work 模型的消息者1得到的 message &#x3D; 消息3</span><br><span class="line">这是 work 模型的消息者2得到的 message &#x3D; 消息4</span><br></pre></td></tr></table></figure>

<h5 id="能者多劳-1"><a href="#能者多劳-1" class="headerlink" title="能者多劳"></a>能者多劳</h5><p>TODO</p>
<h4 id="Fanout-模型"><a href="#Fanout-模型" class="headerlink" title="Fanout 模型"></a>Fanout 模型</h4><ul>
<li>生产者</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FanoutTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fanout 模型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWorkQueues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;ex_logs&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;这是 Fanout 模型发送的消息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>消费者</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为是临时队列，所以不需要进行 queuesToDeclare</span></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = &#123;</span></span><br><span class="line"><span class="meta">            @QueueBinding(</span></span><br><span class="line"><span class="meta">                    //不指定名称的话就会给我们随机创建临时队列</span></span><br><span class="line"><span class="meta">                    value = @Queue,</span></span><br><span class="line"><span class="meta">                    //指定绑定的交换机</span></span><br><span class="line"><span class="meta">                    exchange = @Exchange(value = &quot;ex_logs&quot;, type = &quot;fanout&quot;)</span></span><br><span class="line"><span class="meta">            )</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive1</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者1 message = &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = &#123;</span></span><br><span class="line"><span class="meta">            //不指定名称的话就会给我们随机创建临时队列</span></span><br><span class="line"><span class="meta">            @QueueBinding(</span></span><br><span class="line"><span class="meta">                    value = @Queue,</span></span><br><span class="line"><span class="meta">                    //指定绑定的交换机</span></span><br><span class="line"><span class="meta">                    exchange = @Exchange(value = &quot;ex_logs&quot;, type = &quot;fanout&quot;)</span></span><br><span class="line"><span class="meta">            )</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive2</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者2 message = &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Routing-模型-1"><a href="#Routing-模型-1" class="headerlink" title="Routing 模型"></a>Routing 模型</h4><ul>
<li>生产者</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoutingTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Routing 模型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRouting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;routing_directs&quot;</span>, <span class="string">&quot;info&quot;</span>, <span class="string">&quot;这是 Routing 模型 发送 info 的 key 的信息&quot;</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;routing_directs&quot;</span>, <span class="string">&quot;error&quot;</span>, <span class="string">&quot;这是 Routing 模型 发送 error 的 key 的信息&quot;</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;routing_directs&quot;</span>, <span class="string">&quot;warning&quot;</span>, <span class="string">&quot;这是 Routing 模型 发送 warning 的 key 的信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>消费者</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoutingConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = &#123;</span></span><br><span class="line"><span class="meta">            @QueueBinding(</span></span><br><span class="line"><span class="meta">                    value = @Queue,</span></span><br><span class="line"><span class="meta">                    //默认就是 direct 类型的</span></span><br><span class="line"><span class="meta">                    exchange = @Exchange(value = &quot;routing_directs&quot;, type = &quot;direct&quot;),</span></span><br><span class="line"><span class="meta">                    //接收 3 种类型的 routingKey 信息</span></span><br><span class="line"><span class="meta">                    key = &#123;&quot;info&quot;, &quot;error&quot;, &quot;warning&quot;&#125;</span></span><br><span class="line"><span class="meta">            )</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive1</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者1 接受到的消息 message = &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = &#123;</span></span><br><span class="line"><span class="meta">            @QueueBinding(</span></span><br><span class="line"><span class="meta">                    value = @Queue,</span></span><br><span class="line"><span class="meta">                    //默认就是 direct 类型的</span></span><br><span class="line"><span class="meta">                    exchange = @Exchange(value = &quot;routing_directs&quot;, type = &quot;direct&quot;),</span></span><br><span class="line"><span class="meta">                    //只接收 info 类型的 routingKey 信息</span></span><br><span class="line"><span class="meta">                    key = &#123;&quot;info&quot;&#125;</span></span><br><span class="line"><span class="meta">            )</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive2</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者2 接受到的消息 message = &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Topics-模型-1"><a href="#Topics-模型-1" class="headerlink" title="Topics 模型"></a>Topics 模型</h4><ul>
<li>生产者</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopicsTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Routing 模型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRouting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;ex_topics&quot;</span>, <span class="string">&quot;msg&quot;</span>, <span class="string">&quot;这是 Topics 模型发送的 msg 类型信息&quot;</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;ex_topics&quot;</span>, <span class="string">&quot;msg.info&quot;</span>, <span class="string">&quot;这是 Topics 模型发送的 msg.info 类型信息&quot;</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;ex_topics&quot;</span>, <span class="string">&quot;msg.info.error&quot;</span>, <span class="string">&quot;这是 Topics 模型发送的 msg.info.error 类型信息&quot;</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;ex_topics&quot;</span>, <span class="string">&quot;msg.info.error.system&quot;</span>, <span class="string">&quot;这是 Topics 模型发送的 msg.info.error.system 类型信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>消费者</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicsConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(bindings = &#123;</span></span><br><span class="line"><span class="meta">            @QueueBinding(</span></span><br><span class="line"><span class="meta">                    value = @Queue,</span></span><br><span class="line"><span class="meta">                    exchange = @Exchange(value = &quot;ex_topics&quot;,type = &quot;topic&quot;),</span></span><br><span class="line"><span class="meta">                    // # 可以匹配 n 个单词</span></span><br><span class="line"><span class="meta">                    key = &#123;&quot;msg.#&quot;&#125;</span></span><br><span class="line"><span class="meta">            )</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive1</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是消费者1收到的消息 message = &quot;</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = &#123;</span></span><br><span class="line"><span class="meta">            @QueueBinding(</span></span><br><span class="line"><span class="meta">                    value = @Queue,</span></span><br><span class="line"><span class="meta">                    exchange = @Exchange(value = &quot;ex_topics&quot;,type = &quot;topic&quot;),</span></span><br><span class="line"><span class="meta">                    // * 只能匹配 1 个单词</span></span><br><span class="line"><span class="meta">                    key = &#123;&quot;msg.*&quot;&#125;</span></span><br><span class="line"><span class="meta">            )</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive2</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是消费者2收到的消息 message = &quot;</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RPC-模型-1"><a href="#RPC-模型-1" class="headerlink" title="RPC 模型"></a>RPC 模型</h4><p>Todo</p>
<h4 id="Publisher-Confirms-模型-1"><a href="#Publisher-Confirms-模型-1" class="headerlink" title="Publisher Confirms 模型"></a>Publisher Confirms 模型</h4><p>Todo</p>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="消息队列中，如何保证消息的顺序性？"><a href="#消息队列中，如何保证消息的顺序性？" class="headerlink" title="消息队列中，如何保证消息的顺序性？"></a>消息队列中，如何保证消息的顺序性？</h2><p>拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确实是麻烦点；或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。</p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIyNDU2ODA4OQ==&mid=2247483922&idx=1&sn=09214b2223b780afe441d481ae367c0b&chksm=e80db464df7a3d72b57bf1158478ad3f55c546be15af811f10dc262e0262832c9d67ff887047&scene=21#wechat_redirect">消息队列中，如何保证消息的顺序性？</a></p>
<h2 id="RabbitMQ如何保证消息不被重复消费"><a href="#RabbitMQ如何保证消息不被重复消费" class="headerlink" title="RabbitMQ如何保证消息不被重复消费"></a>RabbitMQ如何保证消息不被重复消费</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhixie/p/13444213.html">《RabbitMQ》如何保证消息不被重复消费</a></p>
<h2 id="rabbitmq系列（三）消息幂等性处理"><a href="#rabbitmq系列（三）消息幂等性处理" class="headerlink" title="rabbitmq系列（三）消息幂等性处理"></a>rabbitmq系列（三）消息幂等性处理</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhixie/p/12204095.html">rabbitmq系列（三）消息幂等性处理</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/fdd94be6037a">消息队列的用途、优缺点、技术选型</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1dE411K7MG">B站编程不良人的MQ消息中间件之RabbitMQ以及整合SpringBoot2.x实战教程》</a></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">D丶Cheng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://chave-z.github.io/posts/b543ced0.html">https://chave-z.github.io/posts/b543ced0.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://chave-z.github.io" target="_blank">D丶Cheng的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a></div><div class="post_share"><div class="social-share" data-image="/null" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/5fe89e0e.html"><img class="prev-cover" src="/null" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ElasticSearch目录</div></div></a></div><div class="next-post pull-right"><a href="/posts/e4de6087.html"><img class="next-cover" src="/null" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">行锁原理</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2022 By D丶Cheng</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/search/local-search.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script></div></body></html>