<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Docker容器数据卷与网络 | D丶Cheng的博客</title><meta name="description" content="Docker 容器数据卷什么是容器数据卷 数据卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性： Docker容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。数据卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删"><meta name="keywords" content="Docker"><meta name="author" content="D丶Cheng"><meta name="copyright" content="D丶Cheng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://chave-z.github.io/posts/8a8d1ac6.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Docker容器数据卷与网络"><meta property="og:url" content="https://chave-z.github.io/posts/8a8d1ac6.html"><meta property="og:site_name" content="D丶Cheng的博客"><meta property="og:description" content="Docker 容器数据卷什么是容器数据卷 数据卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性： Docker容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。数据卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删"><meta property="og:image" content="https://chave-z.github.io/null"><meta property="article:published_time" content="2022-05-07T04:00:00.000Z"><meta property="article:modified_time" content="2022-12-06T06:02:17.821Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '天',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: {"limitCount":50,"languages":{"author":"作者: D丶Cheng","link":"链接: ","source":"来源: D丶Cheng的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2022-12-06 14:02:17'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.1.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/null" onerror="onerror=null;src='https://cdn.staticaly.com/gh/Chave-Z/picture@master/data/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">95</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">17</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 所有文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker-%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">1.</span> <span class="toc-text">Docker 容器数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">1.1.</span> <span class="toc-text">什么是容器数据卷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">数据卷类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.1.</span> <span class="toc-text">数据覆盖问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">如何使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D-amp-%E5%85%B7%E5%90%8D%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">1.3.2.</span> <span class="toc-text">匿名&amp;具名数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">匿名数据卷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D-%E5%85%B7%E5%90%8D-%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">**命名(**具名)数据卷</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%9B%AE%E5%BD%95%E6%9D%83%E9%99%90"><span class="toc-number">1.3.3.</span> <span class="toc-text">容器目录权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83"><span class="toc-number">1.3.4.</span> <span class="toc-text">其它</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker-%E7%BD%91%E7%BB%9C"><span class="toc-number">2.</span> <span class="toc-text">Docker 网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFdocker0%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">什么是docker0？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">2.1.2.</span> <span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">docker 网络原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">2.2.2.</span> <span class="toc-text">结论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%93Link%E5%91%BD%E4%BB%A4%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">2.2.3.</span> <span class="toc-text">–Link命令（了解）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">docker网络模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bridge%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.3.1.</span> <span class="toc-text">bridge模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bridge-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E4%B8%BB%E8%A6%81%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">Bridge 桥接模式主要实现步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bridge%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">Bridge桥接模式的缺陷</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#host%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.3.2.</span> <span class="toc-text">host模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Host%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">Host网络模式的缺陷</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Container%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.3.3.</span> <span class="toc-text">Container网络模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#none%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.3.4.</span> <span class="toc-text">none模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.3.5.</span> <span class="toc-text">自定义网络模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%B7%A8%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE"><span class="toc-number">2.4.</span> <span class="toc-text">如何跨网络访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker%E7%BD%91%E7%BB%9C%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="toc-number">2.5.</span> <span class="toc-text">docker网络主要作用</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">D丶Cheng的博客</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 所有文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Docker容器数据卷与网络</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-07T04:00:00.000Z" title="发表于 2022-05-07 12:00:00">2022-05-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-06T06:02:17.821Z" title="更新于 2022-12-06 14:02:17">2022-12-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Docker/">Docker</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="Docker-容器数据卷"><a href="#Docker-容器数据卷" class="headerlink" title="Docker 容器数据卷"></a>Docker 容器数据卷</h1><h2 id="什么是容器数据卷"><a href="#什么是容器数据卷" class="headerlink" title="什么是容器数据卷"></a>什么是容器数据卷</h2><blockquote>
<p>数据卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：</p>
<p>Docker容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。<strong>数据卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。</strong></p>
</blockquote>
<p><strong>特点：</strong></p>
<ul>
<li>数据卷可在容器之间共享或重用数据</li>
<li>卷中的更改可以直接实时生效</li>
<li>数据卷中的更改不会包含在镜像的更新中</li>
<li>数据卷默认会一直存在，即使容器被删除</li>
<li>数据卷的生命周期一直持续到没有容器使用它为止</li>
</ul>
<p><strong>容器中的管理数据主要有两种方式：</strong></p>
<ul>
<li><p><strong>数据卷：</strong>Data Volumes 容器内数据直接映射到本地主机环境</p>
</li>
<li><p><strong>数据卷容器：</strong>Data Volume Containers 使用特定容器维护数据卷</p>
</li>
</ul>
<p><strong>注：</strong>cp命令也是管理数据的方式，但是基本不会用到。</p>
<h2 id="数据卷类型"><a href="#数据卷类型" class="headerlink" title="数据卷类型"></a><strong>数据卷类型</strong></h2><p>有三种数据卷类型：</p>
<ol>
<li><p>宿主机数据卷：直接在宿主机的文件系统中但是容器可以访问（bind mount） </p>
</li>
<li><p>命名数据卷：磁盘上Docker管理的数据卷，但是这个卷指定了名字。</p>
</li>
<li><p>匿名数据卷：磁盘上Docker管理的数据卷，因为没有指定名字，所以想要找到不容易，Docker来管理这些文件。</p>
</li>
</ol>
<p>数据卷其实都在（如果没有网络文件系统等情况下）宿主机文件系统里面的，只是第一种是在宿主机内的特定目录下，而后两种则在docker管理的目录下，这个目录一般是 /var/lib/docker/volumes/xxxx/_data</p>
<p><strong>推荐使用</strong> 宿主机数据卷 <strong>方式持久化数据</strong></p>
<h3 id="数据覆盖问题"><a href="#数据覆盖问题" class="headerlink" title="数据覆盖问题"></a><strong>数据覆盖问题</strong></h3><p>如果挂载一个空的数据卷到容器中的一个非空目录中，那么这个目录下的文件会被复制到数据卷中。</p>
<p>如果挂载一个非空的数据卷到容器中的一个目录中，那么容器中的目录会显示数据卷中的数据。如果原来容器中的目录有数据，那么原始数据会被隐藏掉。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><blockquote>
<p>docker run -v /宿主机绝对路径目录:/容器内目录 镜像名</p>
<p><strong>建议先创建好目录后再进行数据挂载</strong></p>
</blockquote>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name mysql --privileged=true -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -v /data/mysql:/var/lib/mysql mysql:5.7.31 </span><br></pre></td></tr></table></figure>

<h3 id="匿名-amp-具名数据卷"><a href="#匿名-amp-具名数据卷" class="headerlink" title="匿名&amp;具名数据卷"></a>匿名&amp;具名数据卷</h3><h4 id="匿名数据卷"><a href="#匿名数据卷" class="headerlink" title="匿名数据卷"></a>匿名数据卷</h4><blockquote>
<p>匿名挂载就是在指定数据卷的时候，不指定容器路径对应的主机路径，这样对应映射的主机路径就是默认的路径/var/lib/docker/volumes/中自动生成一个随机命名的文件夹。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# docker run -d -P --name nginx01 -v /etc/nginx nginx</span><br><span class="line">bc96b3eeda762d7f3ed0990b97dffbaffde3e76d7b5f7c67051c06cd4d4d4e06</span><br></pre></td></tr></table></figure>

<p>查看所有的数据卷volume的情况, VOLUME NAME这里的值是真实存在的目录（一般在/var/lib/docker/volumes/中）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# docker volume ls</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     3d36eef7142c28c563e6945d703086101efb9aac31fbe401db1f9a06869bfd69</span><br><span class="line">local     6e35689a5f472a67e2fd3943b9ee5945501fa49aed255bf93d7d7d558422638b</span><br><span class="line">local     1914bdf6c087393c99a470dc137bba2c1880ad7fbb359857ac8818e5e643e119</span><br><span class="line">local     79153f67654c09e5b4c3f4cd19957bce78b82ae7f5ae17e9b6d02989faf32f84</span><br></pre></td></tr></table></figure>

<p>因为没有指定名字，所以想要找到不容易，但是我们可以通过如下命令查找：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# docker inspect nginx01</span><br><span class="line">[</span><br><span class="line">....</span><br><span class="line"> &quot;Mounts&quot;: [</span><br><span class="line">     &#123;</span><br><span class="line">         &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">         &quot;Name&quot;: &quot;1914bdf6c087393c99a470dc137bba2c1880ad7fbb359857ac8818e5e643e119&quot;,</span><br><span class="line">         &quot;Source&quot;: &quot;/var/lib/docker/volumes/1914bdf6c087393c99a470dc137bba2c1880ad7fbb359857ac8818e5e643e119/_data&quot;,</span><br><span class="line">         &quot;Destination&quot;: &quot;/etc/nginx&quot;,</span><br><span class="line">         &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">         &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">         &quot;RW&quot;: true,</span><br><span class="line">         &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">     &#125;</span><br><span class="line"> ]</span><br><span class="line">....</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="命名-具名-数据卷"><a href="#命名-具名-数据卷" class="headerlink" title="**命名(**具名)数据卷"></a>**命名(**具名)数据卷</h4><blockquote>
<p>就是指定文件夹名称，区别于指定路径挂载，这里的指定文件夹名称是在Docker指定的默认数据卷路径下的。通过<code>docker volume ls</code>命令可以查看当前数据卷的目录情况。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# docker run -d -P --name nginx02 -v test-nginx:/etc/nginx nginx</span><br><span class="line">b549334cfd1107010ec858feb5c94a79b1b1062f4be7a9f9593cdab58b01fb49</span><br><span class="line">[root@localhost /]# docker volume ls</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     3d36eef7142c28c563e6945d703086101efb9aac31fbe401db1f9a06869bfd69</span><br><span class="line">local     6e35689a5f472a67e2fd3943b9ee5945501fa49aed255bf93d7d7d558422638b</span><br><span class="line">local     1914bdf6c087393c99a470dc137bba2c1880ad7fbb359857ac8818e5e643e119</span><br><span class="line">local     79153f67654c09e5b4c3f4cd19957bce78b82ae7f5ae17e9b6d02989faf32f84</span><br><span class="line">local     test-nginx</span><br></pre></td></tr></table></figure>

<p>具名数据卷查看数据卷信息就比较简单了：<code>docker volume inspect 数据卷名称</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# docker volume inspect test-nginx</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2022-07-07T14:07:23+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: null,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/test-nginx/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;test-nginx&quot;,</span><br><span class="line">        &quot;Options&quot;: null,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="容器目录权限"><a href="#容器目录权限" class="headerlink" title="容器目录权限"></a>容器目录权限</h3><blockquote>
<p>通过 -v 容器内路径： ro rw 改变读写权限 </p>
<p>ro:readonly 只读<br>rw:readwrite 可读可写 </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /宿主机绝对路径目录:/容器内目录:ro 镜像名 </span><br><span class="line">docker run -it -v /宿主机绝对路径目录:/容器内目录:rw 镜像名 </span><br><span class="line">例如： </span><br><span class="line">docker run -d -P --name nginx01 -v /opt/nginx:/etc/nginx:ro nginx</span><br><span class="line">docker run -d -P --name nginx01 -v /opt/nginx:/etc/nginx:rw nginx</span><br></pre></td></tr></table></figure>

<p>只要看到<strong>ro就说明这个路径只能通过宿主机来操作，容器内部无法操作</strong></p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul>
<li>创建数据卷</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create [OPTIONS] [VOLUME]</span><br></pre></td></tr></table></figure>

<ul>
<li>删除数据卷 </li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume rm [OPTIONS] VOLUME [VOLUME...]</span><br></pre></td></tr></table></figure>

<ul>
<li>无主的数据卷可能会占据很多空间，要清理请使用以下命令</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume prune [OPTIONS]</span><br></pre></td></tr></table></figure>

<p><strong>e.g.</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# docker volume create my-vol</span><br><span class="line">my-vol</span><br><span class="line">[root@localhost /]# docker volume ls</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     my-vol</span><br><span class="line">[root@localhost /]# docker volume rm my-vol</span><br><span class="line">my-vol</span><br><span class="line">[root@localhost /]# docker volume ls</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">[root@localhost /]# docker volume prune</span><br><span class="line">WARNING! This will remove all local volumes not used by at least one container.</span><br><span class="line">Are you sure you want to continue? [y/N] y</span><br><span class="line">Total reclaimed space: 0B</span><br></pre></td></tr></table></figure>

<ul>
<li>删除容器之时删除相关的卷</li>
</ul>
<blockquote>
<p>数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷 。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 docker rm -v 这个命令</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -v 容器id或名字</span><br></pre></td></tr></table></figure>

<h1 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h1><h2 id="什么是docker0？"><a href="#什么是docker0？" class="headerlink" title="什么是docker0？"></a>什么是docker0？</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>当未启动docker时，我们使用ifconfig查看网络可以看到如下的内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ifconfig</span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.26.131  netmask 255.255.255.0  broadcast 192.168.26.255</span><br><span class="line">        inet6 fe80::f872:cd45:fd96:9ae3  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:e9:08:b6  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 768  bytes 74945 (73.1 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 1085  bytes 298038 (291.0 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">virbr0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.122.1  netmask 255.255.255.0  broadcast 192.168.122.255</span><br><span class="line">        ether 52:54:00:85:fc:07  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>有的机器会出现eth0的网络，如果你安装并使用过docker，那么还可能还会有br或者vethe开头的虚拟网桥，但是这些貌似都不重要，重要的是安装完docker以后再使用ifconfig命令查看，可以看到多了一个docker0的虚拟网桥。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ifconfig</span><br><span class="line">docker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        ether 02:42:63:59:22:bb  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.26.131  netmask 255.255.255.0  broadcast 192.168.26.255</span><br><span class="line">        inet6 fe80::f872:cd45:fd96:9ae3  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:e9:08:b6  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 768  bytes 74945 (73.1 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 1085  bytes 298038 (291.0 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">virbr0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.122.1  netmask 255.255.255.0  broadcast 192.168.122.255</span><br><span class="line">        ether 52:54:00:85:fc:07  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>

<p>从上面我们得知了，当Docker 启动时，会自动在主机上创建一个 <code>docker0</code> 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>我们以nginx测试下主机和容器以及容器和容器之间能不能ping通：</p>
<ol>
<li>因为容器里一般没有ping命令，所以我们可以用Dockerfile先简单定制一个镜像</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd /opt/dockerfile/nginx</span><br><span class="line">[root@localhost nginx]# ls</span><br><span class="line">Dockerfile</span><br><span class="line">[root@localhost nginx]# docker build -t cheng-nginx:1.0 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/5 : FROM nginx:latest</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 670dcc86b69d</span></span><br><span class="line">Step 2/5 : MAINTAINER cheng&lt;chave_z@163.com&gt;</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 20c3ab3f0da1</span></span><br><span class="line">Removing intermediate container 20c3ab3f0da1</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 2a913ad1a5fc</span></span><br><span class="line">Step 3/5 : RUN apt-get update</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> d2c54691ac48</span></span><br><span class="line">Get:1 http://deb.debian.org/debian bullseye InRelease [116 kB]</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 5ef39efc718a</span></span><br><span class="line">Step 4/5 : RUN apt -y install iputils-ping</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 573723109c34</span></span><br><span class="line">Step 5/5 : RUN apt -y install iproute2</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> d021ada4b6b4</span></span><br><span class="line">// ....</span><br><span class="line">Successfully built a9450932c5c8</span><br><span class="line">Successfully tagged cheng-nginx:1.0</span><br><span class="line">[root@localhost nginx]# docker images</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">cheng-nginx   1.0       a9450932c5c8   9 seconds ago   162MB</span><br><span class="line">nginx         latest    670dcc86b69d   38 hours ago    142MB</span><br><span class="line">mysql         latest    33037edcac9b   8 days ago      444MB</span><br><span class="line">tomcat        latest    451d25ef4583   3 weeks ago     483MB</span><br></pre></td></tr></table></figure>

<p>上面/opt/dockerfile/nginx的内容为：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件内容如下</span></span><br><span class="line"><span class="keyword">FROM</span> nginx:latest</span><br><span class="line"></span><br><span class="line"><span class="keyword">MAINTAINER</span> cheng&lt;chave_z@<span class="number">163</span>.com&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt -y install iputils-ping</span></span><br><span class="line"><span class="comment"># 安装 ip addr命令</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt -y install iproute2</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建容器，测试是否能ping通</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx]# docker run -d -P --name nginx01 cheng-nginx:1.0</span><br><span class="line">5dd776cf75477cb34c187c2a67fbaf29fbf277179fe2e2078d9aaf8b04e4ce04</span><br><span class="line">[root@localhost nginx]# docker run -d -P --name nginx02 cheng-nginx:1.0</span><br><span class="line">ea71e5b80ba7411d16eea6b229afb3e236dc241fc66d0d74316d3f67369bdf43</span><br><span class="line">[root@localhost nginx]# docker exec -it nginx01 ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">5: eth0@if6: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">[root@localhost nginx]# docker exec -it nginx02 ping 172.17.0.2</span><br><span class="line">PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.114 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.061 ms</span><br><span class="line">[root@localhost nginx]# ping 172.17.0.2</span><br><span class="line">PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.060 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.054 ms</span><br></pre></td></tr></table></figure>

<p>从上面的结果我们能看到 主机和容器 以及 容器和容器 之间都是能相互访问的。那他是什么原理呢？</p>
<h2 id="docker-网络原理"><a href="#docker-网络原理" class="headerlink" title="docker 网络原理"></a>docker 网络原理</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>上文我们知道每一个安装了Docker的linux主机都有一个docker0的虚拟网卡。这是个桥接网卡，使用了veth-pair技术，而每启动一个容器，linux主机就会多了一个虚拟网卡。例如上面我们启动nginx01 执行ip addr 命令我们看到多了一个 <code>5: eth0@if6</code>，我们在主机上执行<code>ip addr</code> 发现主机也会多一个虚拟网卡：</p>
<p><code>6: vethf660ce3@if5</code>，同样的，我们再启动一个nginx03 也会发现一样的情况：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run -d -P --name nginx03 cheng-nginx:1.0</span><br><span class="line">0102fe078ea2530cb1cf359140733ce71dbb7dd4c681a8810a4f55c3d2178c6b</span><br><span class="line">[root@localhost ~]# ip addr</span><br><span class="line"><span class="meta">#</span><span class="bash"> .....</span></span><br><span class="line">8: vethdc49038@if7: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default </span><br><span class="line">    link/ether d2:86:54:c9:4f:91 brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line">    inet6 fe80::d086:54ff:fec9:4f91/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">[root@localhost ~]# docker exec -it nginx03 ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">7: eth0@if8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以看到： 主机上多了一个网卡 8: vethdc49038@if7 容器内也多了一个 7: eth0@if8，反观nginx01看到的现象：</p>
<ul>
<li><p>nginx01与主机：6: vethf660ce3@if5  对应 5: eth0@if6</p>
</li>
<li><p>nginx03与主机：8: vethdc49038@if7  对应 7: eth0@if8</p>
</li>
</ul>
<p>也就是说没启动一个容器，都会有一对网卡出现，veth-pair 就是一对的虚拟设备接口，它都是成对出现的。一端连着协议栈，一端彼此相连着。 </p>
<p>正因为有这个特性，它常常充当着一个桥梁，连接着各种虚拟网络设备! “Bridge、OVS 之间的连接”，“Docker 容器之间的连接” 等等，以此构建出非常复杂的虚拟网络结构，比如 OpenStack Neutron。 上面那个nginx的网络模型图如下：</p>
<p><img src="https://cdn.staticaly.com/gh/Chave-Z/picture@master/202207251322348.png" alt="image-20220725132226276"></p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Docker 随机分配一个本地未占用的私有网段（在 <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc1918">RFC1918 (opens new window)</a>中定义）中的一个地址给 <code>docker0</code> 接口。比如典型的 <code>172.17.42.1</code>，掩码为 <code>255.255.0.0</code>。此后启动的容器内的网口也会自动分配一个同一网段（<code>172.17.0.0/16</code>）的地址。</p>
<p>当创建一个 Docker 容器的时候，同时会创建了一对 <code>veth pair</code> 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 <code>eth0</code>；另一端在本地并被挂载到 <code>docker0</code> 网桥，名称以 <code>veth</code> 开头（例如 <code>vethAQI2QT</code>）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。</p>
<p>Docker中的网络接口默认都是虚拟的接口。虚拟接口的优势就是转发效率极高（因为Linux是在内核中进行数据的复制来实现虚拟接口之间的数据转发，无需通过外部的网络设备交换），对于本地系统和容器系统来说，虚拟接口跟一个正常的以太网卡相比并没有区别，只是他的速度快很多。</p>
<img src="https://vuepress.mirror.docker-practice.com/assets/img/network.6ad909f2.png" alt="image-20220721144345229" style="zoom:67%;" />

<h3 id="–Link命令（了解）"><a href="#–Link命令（了解）" class="headerlink" title="–Link命令（了解）"></a>–Link命令（了解）</h3><p>我们编写一个服务，数据库连接地址原来是使用ip的，如果ip变化就不行了，那我们能不能使用服务名访问呢？jdbc:mysql://mysql:3306，这样的话哪怕mysql重启，我们也不需要修改配置了。因为上文自己定制的镜像命令比较全，所以我们还是用它，具体演示如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先停止nginx03,保留nginx01与nginx02</span></span><br><span class="line">[root@localhost ~]# docker stop nginx03</span><br><span class="line">nginx03</span><br><span class="line">[root@localhost ~]# docker rm nginx03</span><br><span class="line">nginx03</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我们先尝试用容器名ping一下看能不能ping通 </span></span><br><span class="line">[root@localhost ~]# docker exec -it nginx02 ping nginx01</span><br><span class="line">ping: nginx01: Temporary failure in name resolution  # 发现ping不通</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时我们启动一个nginx03并使用--link命令</span></span><br><span class="line">[root@localhost ~]# docker run -d -P --name nginx03 --link nginx02 cheng-nginx:1.0</span><br><span class="line">e36c94df18313671674fbb81602e3b3081ea9b3f3971ca867f0a4cc9576e188c</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这样nginx03就能ping通nginx02了</span></span><br><span class="line">[root@localhost ~]# docker exec -it nginx03 ping nginx02</span><br><span class="line">PING nginx02 (172.17.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from nginx02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.076 ms</span><br><span class="line">64 bytes from nginx02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.053 ms</span><br><span class="line">^C</span><br><span class="line">--- nginx02 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1002ms</span><br><span class="line">rtt min/avg/max/mdev = 0.053/0.064/0.076/0.011 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 但是nginx03就能pingnginx01会失败，这个正常，因为上面的--link命令并没有涉及到nginx01</span></span><br><span class="line">[root@localhost ~]# docker exec -it nginx03 ping nginx01</span><br><span class="line">ping: nginx01: Temporary failure in name resolution</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 但是nginx02就能pingnginx03也会失败了，这是为什么呢？</span></span><br><span class="line">[root@localhost ~]# docker exec -it nginx02 ping nginx03</span><br><span class="line">ping: nginx03: Temporary failure in name resolution</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我们查看一下nginx03和nginx02的host配置</span></span><br><span class="line">[root@localhost ~]# docker exec -it nginx03 cat /etc/hosts</span><br><span class="line">127.0.0.1       localhost</span><br><span class="line">::1     localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0 ip6-localnet</span><br><span class="line">ff00::0 ip6-mcastprefix</span><br><span class="line">ff02::1 ip6-allnodes</span><br><span class="line">ff02::2 ip6-allrouters</span><br><span class="line">172.17.0.3      nginx02 335e2a9c76c6</span><br><span class="line">172.17.0.4      e36c94df1831</span><br><span class="line">[root@localhost ~]# docker exec -it nginx02 cat /etc/hosts</span><br><span class="line">127.0.0.1       localhost</span><br><span class="line">::1     localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0 ip6-localnet</span><br><span class="line">ff00::0 ip6-mcastprefix</span><br><span class="line">ff02::1 ip6-allnodes</span><br><span class="line">ff02::2 ip6-allrouters</span><br><span class="line">172.17.0.3      335e2a9c76c6</span><br></pre></td></tr></table></figure>

<p>从上面的host文件配置可以看出，**–link命令其实就是直接把需要link的主机的域名和ip直接配置到了当前容器的hosts文件中**，所以只有nginx03能ping通nginx02，而且–link早都过时了，我们不推荐使用，可以使用自定义网络的方式来替代它。</p>
<h2 id="docker网络模式"><a href="#docker网络模式" class="headerlink" title="docker网络模式"></a>docker网络模式</h2><blockquote>
<p>Linux 平台下，Docker容器网络资源通过内核的 Network Namespace 机制实现隔离，不同的  Network Namespace 有各自的网络设备、协议栈、路由表、防火墙规则等，反之，同一个 Network Namespace  下的进程共享同一网络试图。通过  Network Namespace 的灵活操纵，Docker 提供了五种容器网络模式。</p>
</blockquote>
<table>
<thead>
<tr>
<th>模式</th>
<th>配置</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>bridge</td>
<td>–net=bridge（或不写）</td>
<td>（默认为该模式）此模式会为每一个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥，通过docker0网桥以及Iptables nat表配置与宿主机通信。</td>
</tr>
<tr>
<td>host</td>
<td>–net=host</td>
<td>容器不会虚拟出自己的网卡，配置自己的IP等，它与宿主机共享Network namespace。</td>
</tr>
<tr>
<td>container</td>
<td>–net=container:NAME_or_ID</td>
<td>新建的容器不会虚拟出自己的网卡以及配置自己的IP，而是和一个指定的容器共享IP、端口范围等。</td>
</tr>
<tr>
<td>none</td>
<td>–net=none</td>
<td>容器有独立的Network namespace，但是没有任何网络设置。</td>
</tr>
<tr>
<td>用户自定义</td>
<td>–net=自定义网络</td>
<td>用户自己使用network相关命令定义网络，创建容器的 时候可以指定为自己定义的网络</td>
</tr>
</tbody></table>
<p>安装Docker后，它会自动创建三个网络模式，可以使用以下命令列出当前已有的网络模式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# docker network ls</span><br><span class="line">NETWORK ID     NAME                  DRIVER    SCOPE</span><br><span class="line">399fe5094d70   bridge                bridge    local</span><br><span class="line">a6ab68c3e731   host                  host      local</span><br><span class="line">cd26a41fdaa7   none                  null      local</span><br></pre></td></tr></table></figure>

<h3 id="bridge模式"><a href="#bridge模式" class="headerlink" title="bridge模式"></a>bridge模式</h3><p>默认的网络模式。bridge模式下容器没有一个公有ip，只有宿主机可以直接访问，外部主机是不可见的，但容器通过宿主机的NAT规则后可以访问外网。</p>
<h4 id="Bridge-桥接模式主要实现步骤"><a href="#Bridge-桥接模式主要实现步骤" class="headerlink" title="Bridge 桥接模式主要实现步骤"></a><strong>Bridge</strong> 桥接模式主要实现步骤</h4><ul>
<li><p>Docker Daemon 利用 veth pair 技术，在宿主机上创建两个虚拟网络接口设备，假设为veth0 和 veth1。而veth pair 技术的特性可以保证无论哪一个 veth 接收到网络报文，都会将报文传输给另一方。</p>
</li>
<li><p>Docker Daemon 将 veth0 附加到 Docker Daemon 创建的 docker0网桥上。保证宿主机的网络报文可以发往 veth0；</p>
</li>
<li><p>Docker Daemon 将 <strong>veth1</strong> 添加到 Docker Container 所属的 namespace 下，并被改名为<strong>eth0</strong>。如此一来，保证宿主机的网络报文若发往 veth0，则立即会被 eth0 接收，实现宿主机到DockerContainer网络的联通性；同时，也保证 Docker Container 单独使用 eth0，<strong>实现容器网络环境的隔离性。</strong></p>
</li>
</ul>
<h4 id="Bridge桥接模式的缺陷"><a href="#Bridge桥接模式的缺陷" class="headerlink" title="Bridge桥接模式的缺陷"></a>Bridge桥接模式的缺陷</h4><ol>
<li><p>最明显的是，该模式下 Docker Container 不具有一个公有 IP，即和宿主机的 eth0 不处于同一个网段。导致的结果是宿主机以外的世界不能直接和容器进行通信。</p>
</li>
<li><p>虽然 NAT 模式经过中间处理实现了这一点，但是 NAT 模式仍然存在问题与不便，如：容器均需要在宿主机上竞争端口，容器内部服务的访问者需要使用服务发现获知服务的外部端口等。</p>
</li>
<li><p>另外 NAT 模式由于是在三层网络上的实现手段，故肯定会影响网络的传输效率。</p>
</li>
</ol>
<p><strong>注意：</strong></p>
<p>veth设备是成双成对出现的，一端是容器内部命名为eth0，一端是加入到网桥并命名的veth（通常命名为veth），它们组成了一个数据传输通道，一端进一端出，veth设备连接了两个网络设备并实现了数据通信</p>
<p><img src="https://cdn.staticaly.com/gh/Chave-Z/picture@master/202207251155118.png" alt="image-20220725115535030"></p>
<h3 id="host模式"><a href="#host模式" class="headerlink" title="host模式"></a>host模式</h3><blockquote>
<p>host网络模式需要在容器创建时指定–network=host</p>
</blockquote>
<p>相当于Vmware中的NAT模式，与宿主机在同一个网络中，但没有独立IP地址。如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p>
<p>使用host模式的容器可以直接使用宿主机的IP地址与外界通信，容器内部的服务端口也可以使用宿主机的端口，不需要进行NAT，host最大的优势就是网络性能比较好，但是docker host上已经使用的端口就不能再用了，网络的隔离性不好。</p>
<p>host 模式是 bridge 桥接模式很好的补充。采用 host 模式的 Docker Container，可以直接使用宿主机的 IP地址与外界进行通信，若宿主机的 eth0 是一个公有 IP，那么容器也拥有这个公有IP。同时容器内服务的端口也可以使用宿主机的端口，无需额外进行 NAT 转换。</p>
<p><strong>host模式可以让容器共享宿主机网络栈，这样的好处是外部主机与容器直接通信，但是容器的网络缺少隔离性。</strong></p>
<h4 id="Host网络模式的缺陷"><a href="#Host网络模式的缺陷" class="headerlink" title="Host网络模式的缺陷"></a>Host网络模式的缺陷</h4><p>最明显的是 Docker Container 网络环境隔离性的弱化。即容器不再拥有隔离、独立的网络环境。</p>
<p>另外，使用 host 模式的 Docker Container 虽然可以让容器内部的服务和传统情况无差别、无改造的使用，但是由于网络隔离性的弱化，该容器会与宿主机共享竞争网络栈的使用；</p>
<p>另外，容器内部将不再拥有所有的端口资源，原因是部分端口资源已经被宿主机本身的服务占用，还有部分端口已经用以 bridge 网络模式容器的端口映射。</p>
<h3 id="Container网络模式"><a href="#Container网络模式" class="headerlink" title="Container网络模式"></a>Container网络模式</h3><blockquote>
<p>在容器创建时使用–network=container:vm1指定。(vm1指定的是运行的容器名)</p>
</blockquote>
<p><strong>一种特殊host网络模式</strong></p>
<p>Container 网络模式是 Docker 中一种较为特别的网络的模式。</p>
<p>处于这个模式下的 Docker 容器会共享一个网络环境，这样两个容器之间可以使用localhost高效快速通信。</p>
<p><strong>缺陷：</strong></p>
<p>它并没有改善容器与宿主机以外世界通信的情况（和桥接模式一样，不能连接宿主机以外的其他设备）。这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。</p>
<p>同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过lo 网卡设备通信。</p>
<h3 id="none模式"><a href="#none模式" class="headerlink" title="none模式"></a>none模式</h3><blockquote>
<p>none模式可以在容器创建时通过–network=none来指定</p>
</blockquote>
<p>使用none模式，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。</p>
<p>这种网络模式下容器只有lo回环网络，没有其他网卡。这种类型的网络没有办法联网，封闭的网络能很好的保证容器的安全性。</p>
<h3 id="自定义网络模式"><a href="#自定义网络模式" class="headerlink" title="自定义网络模式"></a>自定义网络模式</h3><blockquote>
<p>默认情况下，docker容器之间是不能通过容器名来访问的，但是我们能通过自定义网络来解决这个问题，演示如下：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个名为mynet的网络</span></span><br><span class="line">[root@localhost ~]# docker network create mynet</span><br><span class="line">01c9a9709b545f7fd286973b328cb937b619f5a2847f9cac51f38cd5c2514c56</span><br><span class="line">[root@localhost ~]# docker network ls</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">c1850efcce5b   bridge    bridge    local</span><br><span class="line">299055be968e   host      host      local</span><br><span class="line">01c9a9709b54   mynet     bridge    local</span><br><span class="line">f993cb2bafbf   none      null      local</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我们来启动两个容器用于测试，使用自己的自定义网络 mynet</span></span><br><span class="line">[root@localhost ~]# docker run -d -P --name nginx01 --net mynet cheng-nginx:1.0</span><br><span class="line">c089ea53564213a2107e871e462a381049a81b3aa13169d0fc52e4be3f37b4c5</span><br><span class="line">[root@localhost ~]# docker run -d -P --name nginx02 --net mynet cheng-nginx:1.0</span><br><span class="line">73529f983d3e97421af3d2c75108324d6b84f7e74a25410507677b0aae3f8007</span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试在 nginx01 上通过服务名是否能联通 nginx02</span></span><br><span class="line">[root@localhost ~]# docker exec -it nginx01 ping nginx02</span><br><span class="line">PING nginx02 (172.18.0.4) 56(84) bytes of data.</span><br><span class="line">64 bytes from nginx02.mynet (172.18.0.4): icmp_seq=1 ttl=64 time=0.101 ms</span><br><span class="line">64 bytes from nginx02.mynet (172.18.0.4): icmp_seq=2 ttl=64 time=0.057 ms</span><br><span class="line">^C</span><br><span class="line">--- nginx02 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 999ms</span><br><span class="line">rtt min/avg/max/mdev = 0.057/0.079/0.101/0.022 ms</span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试在 nginx02 上通过服务名是否能联通 nginx01</span></span><br><span class="line">[root@localhost ~]# docker exec -it nginx02 ping nginx01</span><br><span class="line">PING nginx01 (172.18.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from nginx01.mynet (172.18.0.3): icmp_seq=1 ttl=64 time=0.064 ms</span><br><span class="line">64 bytes from nginx01.mynet (172.18.0.3): icmp_seq=2 ttl=64 time=0.057 ms</span><br><span class="line">^C</span><br><span class="line">--- nginx01 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 999ms</span><br><span class="line">rtt min/avg/max/mdev = 0.057/0.060/0.064/0.003 ms</span><br></pre></td></tr></table></figure>

<p>从上面的结果能发现，docker自定义的网络本身就会帮我们维护好主机名和ip的对应关系（ip和域名都能ping通） ，所以我们平时都可以这样使用网络。 </p>
<h2 id="如何跨网络访问"><a href="#如何跨网络访问" class="headerlink" title="如何跨网络访问"></a>如何跨网络访问</h2><p>如果要跨网络操作别人，就需要使用<code>docker network connect [OPTIONS] NETWORK CONTAINER</code>连接，操作如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先排除干扰</span></span><br><span class="line">[root@localhost ~]# docker rm -f $(docker ps -aq)</span><br><span class="line">73529f983d3e</span><br><span class="line">c089ea535642</span><br><span class="line">5202e4a761dc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在docker0网络上创建nginx01、nginx02</span></span><br><span class="line">[root@localhost ~]# docker run -d -P --name nginx01 cheng-nginx:1.0</span><br><span class="line">9fe601a78444962d5eadf7b961709c11350ae9a6bb7e8555f48e06a51d0fbd70</span><br><span class="line">[root@localhost ~]# docker run -d -P --name nginx02 cheng-nginx:1.0</span><br><span class="line">d0f2ca7c64d564a3f88c2950bd4905d513e6ce4583f29e06e944740a4155e403</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在自定义网络 mynet 上创建nginx_mynet_01</span></span><br><span class="line">[root@localhost ~]# docker run -d -P --name nginx_mynet_01 --net mynet cheng-nginx:1.0</span><br><span class="line">d0813810affa2a5128e82c636b2cd5ab80da6e45a163fbf1c2ff069588d4c13b</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试docker0上的 nginx01 是否能ping通 mynet 上的 nginx_mynet_01</span></span><br><span class="line">[root@localhost ~]# docker exec -it nginx01 ping nginx_mynet_01</span><br><span class="line">ping: nginx_mynet_01: Temporary failure in name resolution  # 发现不能ping通</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打通mynet-docker0 的网络</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令 docker network connect [OPTIONS] NETWORK CONTAINER</span></span><br><span class="line">[root@localhost ~]# docker network connect mynet nginx01</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 继续测试是否能ping 通，发现 nginx_mynet_01 和 nginx01 已经能连通了</span></span><br><span class="line">[root@localhost ~]# docker exec -it nginx01 ping nginx_mynet_01</span><br><span class="line">PING nginx_mynet_01 (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from nginx_mynet_01.mynet (172.18.0.2): icmp_seq=1 ttl=64 time=0.087 ms</span><br><span class="line">^C</span><br><span class="line">--- nginx_mynet_01 ping statistics ---</span><br><span class="line">1 packets transmitted, 1 received, 0% packet loss, time 0ms</span><br><span class="line">rtt min/avg/max/mdev = 0.087/0.087/0.087/0.000 ms</span><br><span class="line">[root@localhost ~]# docker exec -it nginx_mynet_01 ping nginx01</span><br><span class="line">PING nginx01 (172.18.0.4) 56(84) bytes of data.</span><br><span class="line">64 bytes from nginx01.mynet (172.18.0.4): icmp_seq=1 ttl=64 time=0.110 ms</span><br><span class="line">64 bytes from nginx01.mynet (172.18.0.4): icmp_seq=2 ttl=64 time=0.055 ms</span><br><span class="line">64 bytes from nginx01.mynet (172.18.0.4): icmp_seq=3 ttl=64 time=0.075 ms</span><br><span class="line">^C</span><br><span class="line">--- nginx01 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 1998ms</span><br><span class="line">rtt min/avg/max/mdev = 0.055/0.080/0.110/0.022 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> nginx_mynet_01 和 nginx02 仍旧不通</span></span><br><span class="line">[root@localhost ~]# docker exec -it nginx02 ping nginx_mynet_01</span><br><span class="line">ping: nginx_mynet_01: Temporary failure in name resolution</span><br></pre></td></tr></table></figure>

<h2 id="docker网络主要作用"><a href="#docker网络主要作用" class="headerlink" title="docker网络主要作用"></a>docker网络主要作用</h2><p>docker网络的主要作用如下：</p>
<ul>
<li><strong>容器间的互联和通信以及端口映射</strong></li>
</ul>
<p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。当使用 <code>-P</code> 标记时，Docker 会随机映射一个端口到内部容器开放的网络端口。</p>
<ul>
<li><strong>容器IP变动时候可以通过服务名直接网络通信而不受到影响</strong></li>
</ul>
<p>我们开发的web项目基本都需要连接数据库，那么配置文件里就需要指定数据库的url地址。但是我们用Docker创建数据库事，假设数据库出问题了，我们重新启动运行一个，这个时候数据库容器的地址就会发生变化，因为docker会给每个容器都分配一个ip，且容器和容器之间是可以互相访问的。</p>
<p><strong>参考：</strong></p>
<p>《<a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/">Docker 从入门到实践</a>》</p>
<p>《Docker进阶与实战》</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">D丶Cheng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://chave-z.github.io/posts/8a8d1ac6.html">https://chave-z.github.io/posts/8a8d1ac6.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://chave-z.github.io" target="_blank">D丶Cheng的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Docker/">Docker</a></div><div class="post_share"><div class="social-share" data-image="/null" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/1394dd67.html"><img class="prev-cover" src="/null" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">location及rewrite配置详解</div></div></a></div><div class="next-post pull-right"><a href="/posts/f61655ea.html"><img class="next-cover" src="/null" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Docker镜像</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/5ae6092.html" title="Docker基础"><img class="cover" src="/null"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-04</div><div class="title">Docker基础</div></div></a></div><div><a href="/posts/f61655ea.html" title="Docker镜像"><img class="cover" src="/null"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-05</div><div class="title">Docker镜像</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2022 By D丶Cheng</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/search/local-search.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script></div></body></html>